---
title: "csaw_function_CLEAN_ET"
author: "Eddie Torres"
date: "2025-08-04"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# Set working environment

workingdir="C:/Users/eddie/Research/GitHub"

#set working directory to the correct location for working machine
knitr::opts_knit$set(root.dir = "workingdir")

library(dplyr)
  require(csaw)
  require(edgeR)
  library(GenomicRanges)
  library(Rsamtools)
  library(S4Vectors)
  library(SummarizedExperiment)


```

```{r, read in metadata & regions of interest}
#reading in metdata
meta <- read.csv("../csaw_samples_files/cac_csaw.csv")

#fix path (if necessary, should only be if you're in wrong directory)
meta <- meta %>%
  mutate(bamReads = paste0("../", bamReads))

#Build group factor from csaw metadata
grouping <- factor(paste(meta$Strain, meta$Antibody, sep = "."))

#Design matrix using this grouping for downstream comaprisons
design.mat <- model.matrix(~ 0 + grouping)
colnames(design.mat) <- levels(grouping)

###########remove mat locus               1856250. 1862401 36 - 37
matLocus <- GRanges("CM002236.1", IRanges(1856288, 1862459)) # mat

##set parameters for windowCounts
param <- readParam(discard = matLocus, pe="none", max.frag=1500, minq=20 )

#reading in regions of interest
regions <- list(K27genes_proms = read.table("../bed_files/K27_genes_prom_100pct_overlap.bed"), K27genes = read.table("../bed_files/K27_genes_stringent.bed"), K27proms = read.table("../bed_files/K27_promoters.bed"), K27promTSS = read.table("../bed_files/K27_prom_TSS.bed"), allgenes = read.table("../bed_files/all_genes_forR.bed")) 

new = read.table("../bed_files/H3K27me3_methylated_TSS_Promoters_FINAL.bed")

regions$K27promTSS = subset(regions$K27promTSS, regions$K27promTSS$V10 %in% new$V10)
regions$K27proms = subset(regions$K27proms, regions$K27proms$V10 %in% new$V10)
regions$K27genes_proms = subset(regions$K27genes_proms, regions$K27genes_proms$V10 %in% new$V10)
regions$K27genes= subset(regions$K27genes, regions$K27genes$V10 %in% new$V10)

###IMPORTANT: the tables you  read into your list should not have a header (i.e., the column names should be V1, V2, ... VX). If your columns have other names, the count function may not recognize it properly. even if the files you read in have headers, i believe you can adjust the way read.table reads it into a df object. check column names in the "regions" object before continuing

#with "list" you can read multiple beds into the function

#once you load in all the metadata and bed with regions, run the first function to count data and make a dge object

```

```{r, csaw count & dge function, echo = FALSE}
###KEY NOTE: leave this and the following functions *unedited*, this is the default function, all you need to do is edit the parameters in the block below and its one-click (blocks flanked by hashtags ###). I explain what each paramter does below, and what each consecutive function does in each block###

#This function will count in your data based on your loaded metadata and provided regions of interests. you will want to include any blacklisted regions (i.e. mat locus) with your param object.

csaw_count_and_fit <- function(
  metadata_df,
  region_list = NULL,           # data frame OR named list of data frames (BED-like)
  mode = c("window", "region"), # choose count mode
  window_size = 300,            # used only for window mode
  design_mat,                   # precomputed model matrix
  param,                        # readParam() object (your defaults will be copied)
  assign_to_global = TRUE,      # save named objects to global environment
  return_list = TRUE            # return everything in a nested list
) {
  require(csaw)
  require(edgeR)
  require(GenomicRanges)
  require(Rsamtools)
  require(S4Vectors)
  require(SummarizedExperiment)

  mode <- match.arg(mode)

  ## ---------------- sanity helpers ----------------
  df_to_granges <- function(df) {
    cols <- names(df)
    chr <- if ("V1" %in% cols) df$V1 else if ("chrom" %in% cols) df$chrom else stop("No chrom/V1 column in region data.frame")
    start <- if ("V2" %in% cols) df$V2 else if ("start" %in% cols) df$start else stop("No start/V2 column in region data.frame")
    end   <- if ("V3" %in% cols) df$V3 else if ("end"   %in% cols) df$end   else stop("No end/V3 column in region data.frame")
    strd  <- if ("V6" %in% cols) df$V6 else if ("strand" %in% cols) df$strand else "*"
    start <- as.integer(start); end <- as.integer(end)
    if (any(is.na(start) | is.na(end))) stop("Start/end contain NAs after coercion. Check region input.")
    GRanges(seqnames = chr, ranges = IRanges(start = start, end = end), strand = strd)
  }

  as_named_list <- function(x) {
    if (is.null(x)) return(NULL)
    if (is.list(x) && !is.data.frame(x)) {
      if (is.null(names(x)) || any(names(x) == "")) {
        stop("region_list must be a *named* list, e.g. list(K27genes_proms = df).")
      }
      return(x)
    } else if (is.data.frame(x)) {
      return(list(genome_set = x))
    } else {
      stop("region_list must be a data.frame or a named list of data.frames.")
    }
  }

  detect_paired <- function(bam, n = 5000L) {
    bf <- BamFile(bam, yieldSize = n)
    open(bf); on.exit(close(bf), add = TRUE)
    x <- scanBam(bf, param = ScanBamParam(what = "flag"))[[1]]$flag
    if (length(x) == 0) return(FALSE)
    # bit 0x1 => isPaired
    any(bitwAnd(x, 1L) != 0L)
  }

  # try to clone readParam() while overriding `pe=`
  set_pe <- function(param_in, pe_mode = c("none","both")) {
    pe_mode <- match.arg(pe_mode)
    # Best effort: copy main knobs if present; otherwise fall back to defaults from `param_in`
    # Extract what we can via show() parsing fallback is messy; instead we accept common fields explicitly:
    # If slot access works, use it; otherwise default.
    get_slot <- function(obj, nm, default = NULL) {
      if (nm %in% slotNames(obj)) slot(obj, nm) else default
    }
    rp <- readParam(
      pe      = pe_mode,
      max.frag = get_slot(param_in, "max.frag", 1500L),
      dedup   = get_slot(param_in, "dedup", FALSE),
      minq    = get_slot(param_in, "minq", 20L),
      forward = get_slot(param_in, "forward", NA),
      restrict = get_slot(param_in, "restrict", NULL)
    )
    rp
  }

  stopifnot(is.data.frame(metadata_df))
  needed <- c("Strain","Antibody","bamReads","Replicate")
  if (!all(needed %in% names(metadata_df))) {
    stop("metadata_df must contain columns: Strain, Antibody, Replicate, bamReads")
  }

  # grouping (used for design compatibility check)
  grouping <- factor(paste(metadata_df$Strain, metadata_df$Antibody, sep = "."))
  if (!all(levels(grouping) %in% colnames(design_mat))) {
    missing_cols <- setdiff(levels(grouping), colnames(design_mat))
    stop(paste0("design_mat is missing columns for these groups: ", paste(missing_cols, collapse = ", ")))
  }

  # pretty column labels (samples) used in DGE objects
  nice_labels <- paste(metadata_df$Strain, metadata_df$Antibody, paste0("R", metadata_df$Replicate), sep = ".")

  # normalize region_list input shape
  region_list <- as_named_list(region_list)

  # file existence
  bam_files <- metadata_df$bamReads
  exist <- file.exists(bam_files)
  if (!all(exist)) {
    stop("Missing BAM(s): ", paste(bam_files[!exist], collapse = ", "))
  }

  # warn about old index timestamps (harmless but noisy)
  if (interactive()) {
    bai_exists <- file.exists(paste0(bam_files, ".bai")) | file.exists(sub("\\.bam$", ".bai", bam_files))
    if (!all(bai_exists)) {
      warning("One or more BAM index (.bai) files are missing; samtools will auto-index or counts may be slow.")
    }
  }

  # detect PE/SE per BAM
  is_pe <- vapply(bam_files, detect_paired, logical(1))
  pe_bams <- bam_files[is_pe]
  se_bams <- bam_files[!is_pe]

  if (length(pe_bams) == 0L && length(se_bams) == 0L) stop("No BAMs detected.")
  message(sprintf("Detected %d PE and %d SE BAMs.", length(pe_bams), length(se_bams)))

  # build param variants
  param_pe <- set_pe(param, "both")
  param_se <- set_pe(param, "none")

  # container
  out <- list(genomewide = NULL, regions = list())

  # helper: ensure columns are in the original metadata order
  reorder_se_cols <- function(se_obj, order_bams) {
    cb <- colData(se_obj)
    if (!"bam.files" %in% colnames(cb)) {
      # older csaw versions: rownames of colData are file paths
      current <- rownames(cb)
    } else {
      current <- as.character(cb$bam.files)
    }
    idx <- match(order_bams, current)
    if (anyNA(idx)) {
      stop("Failed to match counted columns back to original BAM order.")
    }
    se_obj[, idx]
  }

  # helper: run windowCounts for a vector of BAMs (possibly length 0)
  run_window <- function(bams, rp) {
    if (length(bams) == 0L) return(NULL)
    windowCounts(bam.files = bams, spacing = window_size, width = window_size,
                 shift = 0, filter = 0, bin = TRUE, param = rp)
  }

  # helper: run regionCounts for a vector of BAMs
  run_region <- function(bams, rp, gr) {
    if (length(bams) == 0L) return(NULL)
    regionCounts(bam.files = bams, regions = gr, param = rp)
  }

  # helper: bind two SE objects after verifying rows match
  bind2 <- function(a, b) {
    if (is.null(a)) return(b)
    if (is.null(b)) return(a)
    if (!identical(rowRanges(a), rowRanges(b))) {
      stop("Row ranges do not match between SE and PE countingâ€”this should not happen. Check genome/spacing/regions.")
    }
    cbind(a, b)
  }

  # helper: fast fail if any sample has zero total counts
  stop_if_zero_totals <- function(se_obj, context_label) {
    tot <- colSums(assay(se_obj))
    bad <- which(tot == 0)
    if (length(bad)) {
      cb <- colData(se_obj)
      labs <- if ("bam.files" %in% colnames(cb)) as.character(cb$bam.files) else rownames(cb)
      stop(sprintf("Zero total counts in %s for samples: %s\nThis yields non-finite offsets; fix inputs or region set and retry.",
                   context_label, paste(labs[bad], collapse = ", ")))
    }
    invisible(NULL)
  }

  ## ---------------- counting & modeling ----------------
  if (mode == "window") {
    message("Counting genome-wide windows (spacing/width = ", window_size, ") ...")

    data_pe <- run_window(pe_bams, param_pe)
    data_se <- run_window(se_bams, param_se)
    data_all <- bind2(data_se, data_pe)
    if (is.null(data_all)) stop("No windows counted (empty result).")

    # Put columns back to original metadata order
    data_all <- reorder_se_cols(data_all, bam_files)

    # fail fast on zero sums
    stop_if_zero_totals(data_all, "genome-wide windows")

    # DGE/disp/fit with sample labels and grouping
    dge_all  <- asDGEList(data_all, group = grouping)
    colnames(dge_all$counts) <- nice_labels
    rownames(dge_all$samples) <- nice_labels

    disp_all <- estimateDisp(dge_all, design_mat)
    fit_all  <- glmQLFit(disp_all, design_mat, robust = TRUE)

    if (assign_to_global) {
      assign("dge_genomewide",  dge_all,  envir = .GlobalEnv)
      assign("disp_genomewide", disp_all, envir = .GlobalEnv)
      assign("fit_genomewide",  fit_all,  envir = .GlobalEnv)
    }
    out$genomewide <- list(dge = dge_all, disp = disp_all, fit = fit_all, counts = data_all)

    # Optional: filtered genome-wide â†’ region subsets
    if (!is.null(region_list)) {
      rr_all <- rowRanges(data_all)
      for (nm in names(region_list)) {
        message("Filtering genome-wide windows to region set: ", nm)
        gr <- df_to_granges(region_list[[nm]])
        keep <- overlapsAny(rr_all, gr, type = "within")
        filtered <- data_all[keep, ]

        stop_if_zero_totals(filtered, paste0("filtered windows (", nm, ")"))

        dge  <- asDGEList(filtered, group = grouping)
        colnames(dge$counts) <- nice_labels
        rownames(dge$samples) <- nice_labels
        disp <- estimateDisp(dge, design_mat)
        fit  <- glmQLFit(disp, design_mat, robust = TRUE)

        safe <- make.names(nm)
        if (assign_to_global) {
          assign(paste0("gr_",   safe), gr,   envir = .GlobalEnv)
          assign(paste0("dge_",  safe), dge,  envir = .GlobalEnv)
          assign(paste0("disp_", safe), disp, envir = .GlobalEnv)
          assign(paste0("fit_",  safe), fit,  envir = .GlobalEnv)
        }
        out$regions[[nm]] <- list(gr = gr, dge = dge, disp = disp, fit = fit, counts = filtered)
      }
    }

  } else { # mode == "region"
    if (is.null(region_list)) stop("In region mode, region_list (one or more BED data.frames) is required.")
    for (nm in names(region_list)) {
      message("Counting over regions: ", nm)
      gr <- df_to_granges(region_list[[nm]])

      counts_pe <- run_region(pe_bams, param_pe, gr)
      counts_se <- run_region(se_bams, param_se, gr)
      counts_all <- bind2(counts_se, counts_pe)
      if (is.null(counts_all)) stop("No region counts returned (empty result).")

      # Reorder to original BAM order
      counts_all <- reorder_se_cols(counts_all, bam_files)

      stop_if_zero_totals(counts_all, paste0("regions (", nm, ")"))

      dge  <- asDGEList(counts_all, group = grouping)
      colnames(dge$counts) <- nice_labels
      rownames(dge$samples) <- nice_labels
      disp <- estimateDisp(dge, design_mat)
      fit  <- glmQLFit(disp, design_mat, robust = TRUE)

      safe <- make.names(nm)
      if (assign_to_global) {
        assign(paste0("gr_",   safe), gr,   envir = .GlobalEnv)
        assign(paste0("dge_",  safe), dge,  envir = .GlobalEnv)
        assign(paste0("disp_", safe), disp, envir = .GlobalEnv)
        assign(paste0("fit_",  safe), fit,  envir = .GlobalEnv)
      }
      out$regions[[nm]] <- list(gr = gr, dge = dge, disp = disp, fit = fit, counts = counts_all)
    }
  }

  if (return_list) return(out) else invisible(NULL)
}


```

###########################################################################################
```{r, run count & fit function, echo = FALSE}

#This is where you change the parameters and run the function
count_results <- csaw_count_and_fit(
  metadata_df = meta,
  region_list = regions,
  mode = "region", #"region" or "window"
  window_size = 300,
  design_mat = design.mat,
  param = param
)

```
###########################################################################################

```{r, csaw QC function}
#This function can be used to run all relevant QC checks on the ChIP data you counted in the first function. you should choose "region" or "window based on what mode you used for the first function

# ---------- QC function (run after your counting/fitting) ----------
qc_csaw <- function(
  metadata_df,
  out_obj = NULL,                    # optional list returned by csaw_count_and_fit(); if NULL we autodiscover from .GlobalEnv
  mode = c("window","region"),       # whichever you actually ran
  out_dir = "qc_csaw",
  which_sets = c("both","genomewide","regions")  # what to QC
) {
  mode <- match.arg(mode)
  which_sets <- match.arg(which_sets)

  stopifnot(is.data.frame(metadata_df))
  if (!all(c("Strain","Antibody","bamReads") %in% names(metadata_df))) {
    stop("metadata_df must have Strain, Antibody, bamReads")
  }

  # --- deps ---
  require(edgeR)
  require(limma)     # <-- add this
  require(ggplot2)

  # --- helpers ---
  safe_dir <- function(d){ 
    if (!dir.exists(d)) dir.create(d, recursive = TRUE)
    normalizePath(d, mustWork = FALSE) 
  }
  png_wrap  <- function(file, expr, w=1800, h=1200, res=200){
    png(file, width=w, height=h, res=res)
    on.exit(dev.off(), add=TRUE)
    force(expr)
  }

  # Discover objects from GlobalEnv if no list provided
  discover_from_global <- function() {
    nm <- ls(.GlobalEnv)
    res <- list()
    if (which_sets %in% c("both","genomewide")) {
      if (all(c("dge_genomewide","disp_genomewide","fit_genomewide") %in% nm)) {
        res$genomewide <- list(
          dge  = get("dge_genomewide",  envir = .GlobalEnv),
          disp = get("disp_genomewide", envir = .GlobalEnv),
          fit  = get("fit_genomewide",  envir = .GlobalEnv)
        )
      }
    }
    if (which_sets %in% c("both","regions")) {
      region_names <- unique(gsub("^(dge|disp|fit)_", "", nm[grepl("^(dge|disp|fit)_", nm)]))
      res$regions <- list()
      for (rn in region_names) {
        if (all(c(paste0("dge_",rn), paste0("disp_",rn), paste0("fit_",rn)) %in% nm)) {
          res$regions[[rn]] <- list(
            dge  = get(paste0("dge_", rn),  envir = .GlobalEnv),
            disp = get(paste0("disp_", rn), envir = .GlobalEnv),
            fit  = get(paste0("fit_", rn),  envir = .GlobalEnv)
          )
        }
      }
    }
    res
  }

  # get objects
  results <- if (!is.null(out_obj)) out_obj else discover_from_global()
  out_dir <- safe_dir(out_dir)

  qc_one <- function(dge, disp, fit, label) {
    subdir <- safe_dir(file.path(out_dir, label))

    # Library size barplot
    libfile <- file.path(subdir, "libsize_barplot.png")
    png_wrap(libfile, {
      barplot(dge$samples$lib.size/1e6, names = colnames(dge), las = 2,
              ylab = "Library size (millions)", main = paste("Library sizes -", label))
    })

    # MDS plot (force limmaâ€™s method for DGEList)
    mdsfile <- file.path(subdir, "MDS_plot.png")
    png_wrap(mdsfile, {
      limma::plotMDS(dge, main = paste("MDS plot -", label))  # <-- changed
      # if you *still* get grief from masking, this is a belt-and-suspenders option:
      # limma::plotMDS(edgeR::cpm(dge, log=TRUE, prior.count=2), main = paste("MDS plot -", label))
    })

    # BCV plot
    bcvfile <- file.path(subdir, "BCV_plot.png")
    png_wrap(bcvfile, {
      edgeR::plotBCV(disp, main = paste("BCV plot -", label))
    })

    # Meanâ€“variance plot (custom, log2 CPM)
    mvfile <- file.path(subdir, "meanvar_plot.png")
    png_wrap(mvfile, {
      cpm_mat <- edgeR::cpm(dge, log = TRUE, prior.count = 2)
      means <- rowMeans(cpm_mat)
      vars  <- apply(cpm_mat, 1, var)
      plot(means, vars, pch = 16, cex = 0.4,
           xlab = "Mean log2 CPM", ylab = "Variance (log2 CPM)",
           main = paste("Meanâ€“Variance (log2 CPM) -", label))
      lines(lowess(means, vars), lwd = 2, col = "red")
    })

    # QL dispersion plot
    qldfile <- file.path(subdir, "QL_dispersion_plot.png")
    png_wrap(qldfile, {
      edgeR::plotQLDisp(fit, main = paste("QL dispersion -", label))
    })
  }

  # Run QC
  if (which_sets %in% c("both","genomewide") && !is.null(results$genomewide)) {
    with(results$genomewide, qc_one(dge, disp, fit, "genomewide"))
  }
  if (which_sets %in% c("both","regions") && !is.null(results$regions)) {
    for (nm in names(results$regions)) {
      with(results$regions[[nm]], qc_one(dge, disp, fit, nm))
    }
  }

  message("QC complete. Plots saved to: ", out_dir)
}

```

###########################################################################################
```{r, Run QC function}

#This is where you change the paramters and run the function
qc_csaw(
  metadata_df = meta,
  out_obj = NULL, # autodiscover from global env, Use "count_results" if variables not in global
  mode = "region", # "region" or "window" depending on choice in count fxn.
  out_dir = "QCTEST", #output directory, name whatever you want
  which_sets = "regions" # "genomewide", "regions", or "both"
)

```
###########################################################################################

```{r, csaw analysis fucntion}
#This function is going to now analyze the data that you have read in, and calculate the signal over background, normalized to input or WT (or another strain for interest). It will make a couple dataframes for each normalization, for each modifcation analyzed: one with all results (log2FC, FDR, etc.), and one with only log2FC values for heatmap generation. There is also options built in to write analyzed data & statistics to a csv, as well as make an igv track for browser visualization.

# - WINDOW mode filters:
#     * vInput: keep windows where at least 1 strain is (FDR<=cut &/or P<=cut) AND logFC>0,
#               then zero per-strain logFC where that strain FAILS (or logFC<=0)
#     * vRef  : keep windows where at least 1 strain is (FDR<=cut &/or P<=cut) (+ or -),
#               then zero per-strain logFC where that strain FAILS.
#     * this is useful for "de-novo" enrichment dsicovery (i.e. like a peak-caller)
#
# - REGION mode filters:
#     * No masking by default; if mask_region=TRUE, zero per-strain logFC by FDR/P-val
# ---- Run csaw contrasts across ALL mods & ALL region sets ----

csaw_analysis <- function(
  metadata_df,
  design_mat,
  mode = c("window","region"),
  out_obj = NULL,
  reference_strain = "WT",
  fdr_cutoff = 0.05,
  pvalue_cutoff = NULL,
  mask_region = FALSE,
  write_csv_results = FALSE,
  write_csv_heatmap = FALSE,
  write_igv = FALSE,
  out_dir = "csaw_results",
  merge_tol = 300,
  # ---- NEW knobs for gene_id attach ----
  add_gene_id = TRUE,
  regions_lookup = NULL,            # named list, e.g. list(K27promTSS = regions$K27promTSS)
  regions_gene_col = NULL,          # force a particular column name in lookup (e.g., "V10"); NULL=auto
  verbose_gene_map = TRUE
) {
  require(edgeR)
  require(limma)
  require(csaw)
  require(GenomicRanges)
  require(S4Vectors)

  mode <- match.arg(mode)
  if (is.null(out_obj)) stop("out_obj is required (use the list returned by csaw_count_and_fit).")
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # ---------- helpers ----------
  order_cols_wt_first <- function(nms, wt = "WT") {
    wt_hit <- grep(paste0("^logFC_", wt, "$"), nms, value = TRUE)
    rest   <- setdiff(nms, wt_hit)
    c(wt_hit, rest)
  }

  # IGV writer: coords from results (ordered to match heatmap rows), values from heatmap
  .write_igv_from_heatmap <- function(res_df, hm_df, file_path) {
    if (!nrow(hm_df)) {
      warning("Heatmap df has 0 rows; skipping IGV: ", basename(file_path))
      return(invisible(NULL))
    }
    res_key <- paste(res_df$seqnames, res_df$start, res_df$end, sep = ".")
    idx <- match(rownames(hm_df), res_key)
    miss <- which(is.na(idx))
    if (length(miss)) {
      warning("Some heatmap rows not found in results; dropping ", length(miss), " rows for IGV.")
      keep <- !is.na(idx)
      hm_df <- hm_df[keep, , drop = FALSE]
      idx <- idx[keep]
      if (!length(idx)) {
        warning("No overlap between heatmap and results; skipping IGV.")
        return(invisible(NULL))
      }
    }
    res_sel <- res_df[idx, c("seqnames","start","end","name"), drop = FALSE]
    out <- cbind(res_sel, hm_df)  # values from heatmap (masked/filtered)
    write.table(out, file_path, sep = "\t", quote = FALSE, row.names = FALSE)
  }

  # store vInput row keys and masked vInput heatmaps per (mod, region_tag)
  keep_coords_env <- new.env(parent = emptyenv())
  vin_heatmap_env <- new.env(parent = emptyenv())

  # ---------- NEW: gene_id helpers (REGION mode only) ----------
  .guess_gene_id_from_gr <- function(gr) {
    if (is.null(gr)) return(NULL)
    mc <- S4Vectors::mcols(gr)
    if (is.null(mc) || ncol(mc) == 0) return(NULL)
    candidates <- c("gene_id","gene","V10","V11","Gene","GeneID","gene_name","Name","name","symbol")
    candidates <- intersect(candidates, colnames(mc))
    if (!length(candidates)) return(NULL)
    if (!is.null(regions_gene_col) && regions_gene_col %in% candidates) {
      vals <- as.character(mc[[regions_gene_col]])
      return(vals)
    }
    for (cn in candidates) {
      vals <- as.character(mc[[cn]])
      if (any(!is.na(vals) & nzchar(vals))) return(vals)
    }
    NULL
  }

  .attach_gene_id_from_df <- function(final_df, df_lookup, region_tag = NA_character_) {
    if (is.null(df_lookup)) return(final_df)
    # figure out columns for chr/start/end
    if (is.null(colnames(df_lookup))) {
      # assume BED-like: first three columns are chr, start, end
      chr_col <- 1; start_col <- 2; end_col <- 3
    } else {
      # prefer typical column names; else fallback to first three
      cn <- colnames(df_lookup)
      chr_col   <- which(cn %in% c("seqnames","chr","chrom","Chromosome","V1"))[1] %||% 1
      start_col <- which(cn %in% c("start","Start","V2"))[1] %||% 2
      end_col   <- which(cn %in% c("end","End","V3"))[1] %||% 3
    }
    # choose gene column
    if (!is.null(regions_gene_col) && regions_gene_col %in% colnames(df_lookup)) {
      gcol <- regions_gene_col
    } else {
      candidates <- c("gene_id","gene","V10","V11","Gene","GeneID","gene_name","Name","name","symbol")
      gcol <- intersect(candidates, colnames(df_lookup))
      gcol <- if (length(gcol)) gcol[1] else NULL
    }
    if (is.null(gcol)) return(final_df)

    look <- data.frame(
      seqnames = as.character(df_lookup[[chr_col]]),
      start    = as.numeric(df_lookup[[start_col]]),
      end      = as.numeric(df_lookup[[end_col]]),
      gene_id  = as.character(df_lookup[[gcol]]),
      stringsAsFactors = FALSE
    )
    key_lookup <- paste(look$seqnames, look$start, look$end, sep=".")
    key_final  <- paste(final_df$seqnames, final_df$start, final_df$end, sep=".")
    final_df$gene_id <- look$gene_id[ match(key_final, key_lookup) ]

    if (isTRUE(verbose_gene_map)) {
      hit <- sum(!is.na(final_df$gene_id))
      message(sprintf("    [gene_id] %s: attached %d/%d matches via regions lookup",
                      as.character(region_tag), hit, nrow(final_df)))
    }
    final_df
  }

  .attach_gene_id_any <- function(final_df, gr_lookup, region_tag) {
    if (!add_gene_id) return(final_df)
    # 1) Try GRanges mcols
    vals <- .guess_gene_id_from_gr(gr_lookup)
    if (!is.null(vals)) {
      df <- data.frame(
        seqnames = as.character(GenomicRanges::seqnames(gr_lookup)),
        start    = GenomicRanges::start(gr_lookup),
        end      = GenomicRanges::end(gr_lookup),
        gene_id  = as.character(vals),
        stringsAsFactors = FALSE
      )
      key_lookup <- paste(df$seqnames, df$start, df$end, sep=".")
      key_final  <- paste(final_df$seqnames, final_df$start, final_df$end, sep=".")
      final_df$gene_id <- df$gene_id[ match(key_final, key_lookup) ]
      if (isTRUE(verbose_gene_map)) {
        hit <- sum(!is.na(final_df$gene_id))
        message(sprintf("    [gene_id] %s: attached %d/%d matches from GRanges mcols",
                        as.character(region_tag), hit, nrow(final_df)))
      }
      if (any(!is.na(final_df$gene_id))) return(final_df)
      # else fall through to lookup table
    }

    # 2) Try explicit regions_lookup list
    if (!is.null(regions_lookup) && !is.null(regions_lookup[[region_tag]])) {
      return(.attach_gene_id_from_df(final_df, regions_lookup[[region_tag]], region_tag))
    }

    # 3) Try global 'regions' list if present
    regions_global <- get0("regions", envir = .GlobalEnv, inherits = TRUE)
    if (is.list(regions_global) && !is.null(regions_global[[region_tag]])) {
      return(.attach_gene_id_from_df(final_df, regions_global[[region_tag]], region_tag))
    }

    if (isTRUE(verbose_gene_map)) {
      message(sprintf("    [gene_id] %s: no suitable gene source found; leaving gene_id empty.", as.character(region_tag)))
    }
    final_df
  }
  # ---------- end helpers ----------

  run_norm <- function(mod, fit, counts, region_tag, norm_type, gr_for_region = NULL) {
    res_list <- list()
    strains_all <- unique(metadata_df$Strain)
    strains <- if (norm_type == "input") strains_all else setdiff(strains_all, reference_strain)

    for (st in strains) {
      chip_col <- paste0(st, ".", mod)
      if (norm_type == "input") {
        st_input_col <- paste0(st, ".input")
        if (!(chip_col %in% colnames(design_mat)) || !(st_input_col %in% colnames(design_mat))) {
          message("    Skipping ", st, " (missing ", chip_col, " or ", st_input_col, ")")
          next
        }
        constr <- sprintf("`%s` - `%s`", chip_col, st_input_col)
      } else {
        st_input_col  <- paste0(st,               ".input")
        ref_chip_col  <- paste0(reference_strain, ".", mod)
        ref_input_col <- paste0(reference_strain, ".input")
        needed <- c(chip_col, st_input_col, ref_chip_col, ref_input_col)
        if (!all(needed %in% colnames(design_mat))) {
          missing <- paste(setdiff(needed, colnames(design_mat)), collapse = ", ")
          message("    Skipping ", st, " (missing: ", missing, ")")
          next
        }
        # still compute the proper contrast for the RESULTS table
        constr <- sprintf("`%s` - `%s` - (`%s` - `%s`)", chip_col, st_input_col, ref_chip_col, ref_input_col)
      }

      contrast <- limma::makeContrasts(contrasts = constr, levels = design_mat)
      res <- edgeR::glmQLFTest(fit, contrast = contrast)

      if (mode == "window") {
        merged <- mergeResults(counts, res$table, tol = merge_tol, merge.args = list(max.width = merge_tol))
        gr <- merged$regions
        mcols(gr) <- S4Vectors::DataFrame(merged$combined)
      } else {
        gr <- if (!is.null(gr_for_region)) gr_for_region else rowRanges(counts)
        m <- S4Vectors::mcols(gr)
        m$logFC  <- res$table$logFC
        m$PValue <- res$table$PValue
        m$FDR    <- if ("FDR" %in% colnames(res$table)) res$table$FDR else p.adjust(res$table$PValue, method = "BH")
        S4Vectors::mcols(gr) <- m
      }
      res_list[[st]] <- gr
    }

    if (length(res_list) == 0) return(NULL)

    base <- res_list[[1]]
    base_key_coords <- paste0(as.character(seqnames(base)), ".", start(base), ".", end(base))

    # RESULTS (never filtered/masked)
    final_df <- data.frame(
      seqnames = as.character(GenomicRanges::seqnames(base)),
      start    = GenomicRanges::start(base),
      end      = GenomicRanges::end(base),
      name     = rep(".", length(base)),
      strand   = as.character(GenomicRanges::strand(base)),
      stringsAsFactors = FALSE
    )
    for (st in names(res_list)) {
      gr <- res_list[[st]]
      mnames <- colnames(S4Vectors::mcols(gr))
      lfc_col <- if ("rep.logFC" %in% mnames) "rep.logFC" else
                 if ("logFC" %in% mnames) "logFC" else
                 stop("Neither rep.logFC nor logFC found for ", st, " (", mod, ")")
      final_df[[paste0("logFC_", st)]]  <- S4Vectors::mcols(gr)[[lfc_col]]
      final_df[[paste0("PValue_", st)]] <- S4Vectors::mcols(gr)[["PValue"]]
      final_df[[paste0("FDR_", st)]]    <- if ("FDR" %in% mnames) S4Vectors::mcols(gr)[["FDR"]] else
        p.adjust(S4Vectors::mcols(gr)[["PValue"]], method = "BH")
    }

    # ---- NEW: attach gene_id for REGION mode by (chr,start,end) ----
    if (identical(mode, "region") && isTRUE(add_gene_id)) {
      final_df <- .attach_gene_id_any(final_df, gr_for_region, region_tag)
    }

    # HEATMAP (masked/filtered)
    logfc_cols <- grep("^logFC_", colnames(final_df), value = TRUE)
    logfc_cols <- order_cols_wt_first(logfc_cols, wt = reference_strain)
    heatmap_df <- final_df[, logfc_cols, drop = FALSE]
    rownames(heatmap_df) <- base_key_coords

    if (mode == "window") {
      if (norm_type == "input") {
        # per-strain masking & keep rows with any positive/sig
        for (st in sub("^logFC_", "", logfc_cols)) {
          lcol <- paste0("logFC_",  st)
          fcol <- paste0("FDR_",    st)
          pcol <- paste0("PValue_", st)
          mask <- (heatmap_df[[lcol]] <= 0)
          if (!is.null(fdr_cutoff)    && fcol %in% colnames(final_df))  mask <- mask | (final_df[[fcol]] > fdr_cutoff)
          if (!is.null(pvalue_cutoff) && pcol %in% colnames(final_df))  mask <- mask | (final_df[[pcol]] > pvalue_cutoff)
          heatmap_df[[lcol]][mask] <- 0
        }
        keep_any <- rowSums(heatmap_df > 0, na.rm = TRUE) > 0
        heatmap_df <- heatmap_df[keep_any, , drop = FALSE]

        key <- paste(mod, region_tag, sep = "::")
        keep_coords_env[[key]] <- rownames(heatmap_df)
        vin_heatmap_env[[key]] <- heatmap_df  # store masked vInput for vWT derivation

      } else {
        # vWT derived from vInput: (strain - WT) row-wise using masked vInput values
        key <- paste(mod, region_tag, sep = "::")
        vin <- vin_heatmap_env[[key]]

        if (is.null(vin)) {
          warning("No stored vInput heatmap for ", key, "; falling back to contrast-based masking.")
          kept_coords <- keep_coords_env[[key]]
          keep_rows <- if (is.null(kept_coords)) rep(TRUE, nrow(heatmap_df)) else (rownames(heatmap_df) %in% kept_coords)
          for (st in sub("^logFC_", "", logfc_cols)) {
            lcol <- paste0("logFC_",  st)
            fcol <- paste0("FDR_",    st)
            pcol <- paste0("PValue_", st)
            mask <- rep(FALSE, nrow(final_df))
            if (!is.null(fdr_cutoff)    && fcol %in% colnames(final_df))  mask <- mask | (final_df[[fcol]] > fdr_cutoff)
            if (!is.null(pvalue_cutoff) && pcol %in% colnames(final_df))  mask <- mask | (final_df[[pcol]] > pvalue_cutoff)
            heatmap_df[[lcol]][mask] <- 0
          }
          heatmap_df <- heatmap_df[keep_rows, , drop = FALSE]
        } else {
          wt_col <- paste0("logFC_", reference_strain)
          if (!(wt_col %in% colnames(vin))) {
            warning("WT column (", wt_col, ") not found in vInput heatmap for ", key, "; cannot compute vWT from vInput.")
            kept_coords <- keep_coords_env[[key]]
            keep_rows <- if (is.null(kept_coords)) rep(TRUE, nrow(heatmap_df)) else (rownames(heatmap_df) %in% kept_coords)
            heatmap_df <- heatmap_df[keep_rows, , drop = FALSE]
          } else {
            # make sure same row set & order as vInput
            heatmap_df <- vin
            # subtract WT row-wise, drop WT column
            non_wt_cols <- setdiff(colnames(heatmap_df), wt_col)
            if (length(non_wt_cols)) {
              heatmap_df <- sweep(heatmap_df[, non_wt_cols, drop = FALSE], 1, vin[[wt_col]], FUN = "-")
            } else {
              heatmap_df <- heatmap_df[, 0, drop = FALSE]
            }
          }
        }
      }

    } else {
      # REGION MODE: optional masking only (heatmap df stays numeric-only; no gene_id here)
      if (isTRUE(mask_region)) {
        for (st in sub("^logFC_", "", logfc_cols)) {
          lcol <- paste0("logFC_",  st)
          fcol <- paste0("FDR_",    st)
          pcol <- paste0("PValue_", st)
          mask <- rep(FALSE, nrow(final_df))
          if (!is.null(fdr_cutoff)    && fcol %in% colnames(final_df))  mask <- mask | (final_df[[fcol]] > fdr_cutoff)
          if (!is.null(pvalue_cutoff) && pcol %in% colnames(final_df))  mask <- mask | (final_df[[pcol]] > pvalue_cutoff)
          heatmap_df[[lcol]][mask] <- 0
        }
      }
    }

    list(results = final_df, heatmap = heatmap_df)
  }

  all_mods <- setdiff(unique(metadata_df$Antibody), "input")

  if (mode == "region") {
    if (is.null(out_obj$regions) || !length(out_obj$regions)) stop("No region sets found in out_obj$regions.")
    for (nm in names(out_obj$regions)) {
      rg <- out_obj$regions[[nm]]
      fit    <- rg$fit
      counts <- rg$counts
      gr_in  <- if (!is.null(rg$gr)) rg$gr else rowRanges(counts)

      message("=== Region set: ", nm, " ===")
      for (mod in all_mods) {
        if (identical(mod, "input")) next

        # vInput
        res_vin <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "input", gr_for_region = gr_in)
        if (!is.null(res_vin)) {
          res_df <- res_vin$results
          hm_df  <- res_vin$heatmap
          res_name <- paste0(mod, "_Results_", nm, "_vInput")
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_vInput")
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_vInput.igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("  Modification: ", mod, "\n    -> Saved: ", res_name, " (and ", hm_name, ")")
        }

        # vWT (derived from vInput if available)
        res_vref <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "ref", gr_for_region = gr_in)
        if (!is.null(res_vref)) {
          res_df <- res_vref$results
          hm_df  <- res_vref$heatmap
          norm_tag <- paste0("v", reference_strain)
          res_name <- paste0(mod, "_Results_", nm, "_", norm_tag)
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_", norm_tag)
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_", norm_tag, ".igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("    -> Saved: ", res_name, " (and ", hm_name, ")")
        }
      }
    }
  } else {
    # WINDOW MODE
    if (!is.null(out_obj$genomewide)) {
      gw <- out_obj$genomewide
      fit    <- gw$fit
      counts <- gw$counts
      nm <- "GenomeWide"
      message("=== Window mode: ", nm, " ===")
      for (mod in all_mods) {
        if (identical(mod, "input")) next

        # vInput
        res_vin <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "input", gr_for_region = NULL)
        if (!is.null(res_vin)) {
          res_df <- res_vin$results
          hm_df  <- res_vin$heatmap
          res_name <- paste0(mod, "_Results_", nm, "_vInput")
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_vInput")
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_vInput.igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("  Modification: ", mod, "\n    -> Saved: ", res_name, " (and ", hm_name, ")")
        }

        # vWT (derived from vInput)
        res_vref <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "ref", gr_for_region = NULL)
        if (!is.null(res_vref)) {
          res_df <- res_vref$results
          hm_df  <- res_vref$heatmap
          norm_tag <- paste0("v", reference_strain)
          res_name <- paste0(mod, "_Results_", nm, "_", norm_tag)
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_", norm_tag)
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_", norm_tag, ".igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("    -> Saved: ", res_name, " (and ", hm_name, ")")
        }
      }
    }

    # genomewide filtered to regions (if present) â€” remains WINDOW logic (no gene_id attach)
    if (!is.null(out_obj$regions) && length(out_obj$regions)) {
      for (nm in names(out_obj$regions)) {
        rg <- out_obj$regions[[nm]]
        fit    <- rg$fit
        counts <- rg$counts
        message("=== Window mode (filtered to regions): ", nm, " ===")
        for (mod in all_mods) {
          if (identical(mod, "input")) next

          # vInput
          res_vin <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "input", gr_for_region = NULL)
          if (!is.null(res_vin)) {
            res_df <- res_vin$results
            hm_df  <- res_vin$heatmap
            res_name <- paste0(mod, "_Results_", nm, "_vInput")
            hm_name  <- paste0(mod, "_Heatmap_", nm, "_vInput")
            assign(res_name, res_df, envir = .GlobalEnv)
            assign(hm_name,  hm_df,  envir = .GlobalEnv)
            if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
            if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
            if (write_igv) {
              igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_vInput.igv"))
              .write_igv_from_heatmap(res_df, hm_df, igv_file)
            }
            message("  Modification: ", mod, "\n    -> Saved: ", res_name, " (and ", hm_name, ")")
          }

          # vWT (derived from vInput)
          res_vref <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "ref", gr_for_region = NULL)
          if (!is.null(res_vref)) {
            res_df <- res_vref$results
            hm_df  <- res_vref$heatmap
            norm_tag <- paste0("v", reference_strain)
            res_name <- paste0(mod, "_Results_", nm, "_", norm_tag)
            hm_name  <- paste0(mod, "_Heatmap_", nm, "_", norm_tag)
            assign(res_name, res_df, envir = .GlobalEnv)
            assign(hm_name,  hm_df,  envir = .GlobalEnv)
            if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
            if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
            if (write_igv) {
              igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_", norm_tag, ".igv"))
              .write_igv_from_heatmap(res_df, hm_df, igv_file)
            }
            message("    -> Saved: ", res_name, " (and ", hm_name, ")")
          }
        }
      }
    }
  }
}

```

###########################################################################################
```{r, run analysis function}

csaw_analysis(
  metadata_df = meta,
  design_mat  = design.mat,
  mode        = "region",             # "window" or "region"
  out_obj     = count_results,        # <- REQUIRED so we have counts for merging/coords
  reference_strain = "WT",
  fdr_cutoff  = NULL,
  pvalue_cutoff = NULL, 
  write_csv_results = FALSE,
  write_csv_heatmap = FALSE,
  write_igv   = FALSE,
  mask_region = FALSE,
  out_dir     = "TEST", #output dir, name whatever you want
  merge_tol   = 300                   # only affects genomewide window mode
)

```
###########################################################################################

```{r, Heatmap Function}
#This function will be used to generate desired heatmaps using the generated dfs from the analysis function

# --- Heatmap helper for csaw *_Heatmap_* data frames ---
make_csaw_heatmap_clusterby <- function(
  df,
  plot_cols        = NULL,
  cluster_by       = c("cac1","cac2"),
  collapse_mutants = FALSE,
  fold_cutoff      = 1,                 # set NULL to derive from zero_white_band
  sort_reference   = c("WT"),
  sort_decreasing  = TRUE,

  cap_percentile   = 0.995,
  clip_negatives_to_zero = FALSE,
  color_limits     = NULL,
  colors           = NULL,
  zero_white_band  = NULL,
  show_row_names   = FALSE,
  show_col_names   = TRUE,
  cluster_cols     = FALSE,
  row_slice_gap_mm = 0,   # 0 = no gaps between clusters
  col_slice_gap_mm = 1,   # only used if you ever use column_split
  out_dir   = "csaw_heatmaps",
  out_stem  = "csaw_heatmap_clusterby",
  formats   = c("pdf","png"),
  width_in  = 6.5,
  base_height_in = 1.5,
  per_row_height_in = 0.006,
  dpi       = 300,
  return_objects = TRUE
){
  stopifnot(is.data.frame(df))
  lfccols <- grep("^logFC_", names(df), value = TRUE)
  if (!length(lfccols)) stop("No 'logFC_*' columns found.")
  M_all <- as.matrix(df[, lfccols, drop = FALSE])
  rownames(M_all) <- if (!is.null(rownames(df))) rownames(df) else paste0("row", seq_len(nrow(df)))
  strains_all <- sub("^logFC_", "", colnames(M_all))

  # validate cluster_by
  if (!all(cluster_by %in% strains_all)) {
    miss <- setdiff(cluster_by, strains_all)
    stop("cluster_by strains not found in df: ", paste(miss, collapse = ", "))
  }

  # pick plot columns
  if (is.null(plot_cols)) plot_cols <- strains_all
  if (!all(plot_cols %in% strains_all)) {
    miss <- setdiff(plot_cols, strains_all)
    stop("plot_cols strains not found in df: ", paste(miss, collapse = ", "))
  }
  M <- M_all[, paste0("logFC_", plot_cols), drop = FALSE]
  colnames(M) <- plot_cols

  # derive cutoff from zero_white_band if requested
  cut <- if (is.null(fold_cutoff)) {
    if (!is.null(zero_white_band)) {
      if (length(zero_white_band) == 1) abs(zero_white_band) else max(abs(zero_white_band))
    } else {
      1
    }
  } else {
    as.numeric(fold_cutoff)
  }

  # cap & clip for plotting only
  if (!is.null(cap_percentile)) {
    cap <- as.numeric(stats::quantile(M, probs = cap_percentile, na.rm = TRUE))
    M[M > cap] <- cap
  }
  if (clip_negatives_to_zero) M[M < 0] <- 0

  # Build an 'orig' matrix only for strains that actually exist
  want_for_orig <- unique(c(plot_cols, cluster_by, sort_reference))
  have_for_orig <- intersect(want_for_orig, strains_all)  # drop missing (e.g., WT in vWT frames)
  if (!length(have_for_orig)) stop("No usable columns found for internal logic.")
  orig <- M_all[, paste0("logFC_", have_for_orig), drop = FALSE]
  colnames(orig) <- have_for_orig

  # Ensure cluster_by present in 'orig'
  if (!all(cluster_by %in% colnames(orig))) {
    stop("cluster_by strains are not present in df columns: ",
         paste(setdiff(cluster_by, colnames(orig)), collapse = ", "))
  }

  # state map using 'cut'
  state_for <- function(strains) {
    vals <- orig[, strains, drop = FALSE]
    d <- matrix(0L, nrow(vals), ncol(vals), dimnames = dimnames(vals))
    d[vals <= -abs(cut)] <- -1L  # loss
    d[vals >=  abs(cut)] <-  1L  # gain
    d
  }
  state_cluster <- state_for(cluster_by)

  # clusters
  cluster_labels <- character(nrow(M))
  if (!collapse_mutants) {
    if (length(cluster_by) != 2L) {
      stop("separate mode requires exactly two 'cluster_by' strains. Given: ", paste(cluster_by, collapse = ", "))
    }
    a <- cluster_by[1]; b <- cluster_by[2]
    sA <- state_cluster[, a]; sB <- state_cluster[, b]

    lab <- rep("other", nrow(M))
    lab[sA == -1L & sB == -1L] <- sprintf("loss in both (%s & %s)", a, b)
    lab[sA == -1L & sB ==  0L] <- sprintf("loss in %s only", a)
    lab[sA ==  0L & sB == -1L] <- sprintf("loss in %s only", b)
    lab[sA ==  0L & sB ==  0L] <- sprintf("kept in both (%s & %s)", a, b)

    lvl <- c(sprintf("loss in both (%s & %s)", a, b),
             sprintf("loss in %s only", a),
             sprintf("loss in %s only", b),
             sprintf("kept in both (%s & %s)", a, b),
             "other")
    cluster_labels <- factor(lab, levels = lvl, ordered = TRUE)
  } else {
    targets <- setdiff(cluster_by, "WT"); if (!length(targets)) targets <- cluster_by
    st <- state_cluster[, targets, drop = FALSE]
    loss_any <- apply(st == -1L, 1, any, na.rm = TRUE)
    keep_all <- apply(st ==  0L, 1, all, na.rm = TRUE)
    gain_any <- apply(st ==  1L, 1, any, na.rm = TRUE)

    lab <- rep("other", nrow(M))
    lab[loss_any] <- sprintf("loss in any (%s)", paste(targets, collapse = " | "))
    lab[!loss_any & keep_all] <- sprintf("kept in all (%s)", paste(targets, collapse = " & "))
    lab[!loss_any & !keep_all & gain_any] <- sprintf("gain in any (%s)", paste(targets, collapse = " | "))

    lvl <- c(sprintf("loss in any (%s)", paste(targets, collapse = " | ")),
             sprintf("kept in all (%s)", paste(targets, collapse = " & ")),
             sprintf("gain in any (%s)", paste(targets, collapse = " | ")),
             "other")
    cluster_labels <- factor(lab, levels = lvl, ordered = TRUE)
  }

  # ordering inside each cluster
  cluster_levels <- levels(cluster_labels)

  # predefine exclusions for separate mode
  excl_by_cluster <- list()
  if (!collapse_mutants && length(cluster_by) == 2L) {
    a <- cluster_by[1]; b <- cluster_by[2]
    excl_by_cluster[[sprintf("loss in both (%s & %s)", a, b)]] <- c(a, b)
    excl_by_cluster[[sprintf("loss in %s only", a)]]           <- c(a)
    excl_by_cluster[[sprintf("loss in %s only", b)]]           <- c(b)
    excl_by_cluster[[sprintf("kept in both (%s & %s)", a, b)]] <- character(0)
    excl_by_cluster[["other"]]                                  <- character(0)
  }

  # helpers
  get_vals <- function(rows, use_cols) {
    if (!length(use_cols)) return(matrix(numeric(0), nrow = length(rows)))
    use_cols <- intersect(use_cols, colnames(orig))
    if (!length(use_cols)) return(matrix(numeric(0), nrow = length(rows)))
    orig[rows, use_cols, drop = FALSE]
  }

  ord <- integer(0)
  split_for_ht <- cluster_labels

  for (cl in cluster_levels) {
    idx <- which(cluster_labels == cl)
    if (!length(idx)) next

    cols_for_sort <- cluster_by

    if (!collapse_mutants && length(cluster_by) == 2L) {
      to_exclude <- unique(excl_by_cluster[[cl]] %||% character(0))
      cols_for_sort <- setdiff(cols_for_sort, to_exclude)
    }

    scores <- rep(NA_real_, length(idx))

    if (!collapse_mutants) {
      # simple mean across allowed cluster_by columns; if none, try sort_reference; else mean of cluster_by
      if (length(cols_for_sort)) {
        scores <- rowMeans(get_vals(idx, cols_for_sort), na.rm = TRUE)
      }
      if (all(is.na(scores))) {
        ref_cols <- intersect(sort_reference, colnames(orig))
        if (length(ref_cols)) scores <- rowMeans(get_vals(idx, ref_cols), na.rm = TRUE)
        if (all(is.na(scores))) scores <- rowMeans(get_vals(idx, cluster_by), na.rm = TRUE)
      }
    } else {
      # collapse mode: per-row, drop lost targets from scoring
      targets <- setdiff(cluster_by, "WT"); if (!length(targets)) targets <- cluster_by
      st_rows <- state_cluster[idx, , drop = FALSE]
      for (i in seq_along(idx)) {
        keep_cols <- cols_for_sort
        lost_here <- names(which(st_rows[i, targets, drop = FALSE] == -1L))
        keep_cols <- setdiff(keep_cols, lost_here)
        if (!length(keep_cols)) {
          ref_cols <- intersect(sort_reference, colnames(orig))
          keep_cols <- if (length(ref_cols)) ref_cols else cluster_by
        }
        scores[i] <- mean(orig[idx[i], intersect(keep_cols, colnames(orig))], na.rm = TRUE)
      }
    }

    o <- order(scores, decreasing = sort_decreasing, na.last = TRUE)
    ord <- c(ord, idx[o])
  }

  M <- M[ord, , drop = FALSE]
  split_for_ht <- split_for_ht[ord]

  # colors
  lims <- if (is.null(color_limits)) {
    c(min(M, na.rm = TRUE), max(M, na.rm = TRUE))
  } else {
    out <- as.numeric(color_limits)
    if (any(is.na(out))) {
      if (is.na(out[1])) out[1] <- min(M, na.rm = TRUE)
      if (is.na(out[2])) out[2] <- max(M, na.rm = TRUE)
    }
    out
  }

  # build color function (supports optional white band around 0)
  if (is.function(colors)) {
    col_fun <- colors
  } else if (!is.null(zero_white_band) && lims[1] < 0 && lims[2] > 0) {
    band <- if (length(zero_white_band) == 1) c(-abs(zero_white_band), abs(zero_white_band))
            else sort(as.numeric(zero_white_band))[1:2]
    neg_col <- if (is.null(colors)) "#3B4CC0" else colors[[1]]
    pos_col <- if (is.null(colors)) "#B40426" else tail(colors, 1)
    mid_col <- "white"
    brks <- c(lims[1], band[1], 0, band[2], lims[2])
    cols <- c(neg_col, mid_col, mid_col, mid_col, pos_col)
    col_fun <- circlize::colorRamp2(brks, cols)
  } else {
    if (is.null(colors)) {
      if (lims[1] < 0 && lims[2] > 0) {
        col_fun <- circlize::colorRamp2(c(lims[1], 0, lims[2]),
                                        c("#3B4CC0", "#F7F7F7", "#B40426"))
      } else {
        col_fun <- circlize::colorRamp2(c(lims[1], lims[2]),
                                        c("white", "#006400"))
      }
    } else {
      if (length(colors) == 2) {
        col_fun <- circlize::colorRamp2(c(lims[1], lims[2]), colors)
      } else if (length(colors) >= 3 && lims[1] < 0 && lims[2] > 0) {
        col_fun <- circlize::colorRamp2(c(lims[1], 0, lims[2]),
                                        c(colors[1], colors[2], tail(colors, 1)))
      } else {
        col_fun <- circlize::colorRamp2(seq(lims[1], lims[2], length.out = length(colors)), colors)
      }
    }
  }

  ht <- Heatmap(
    M,
    name = "signal",
    col = col_fun,
    cluster_rows = FALSE,
    cluster_columns = cluster_cols,
    show_row_names = show_row_names,
    show_column_names = show_col_names,
    row_split = split_for_ht,
    row_gap    = unit(row_slice_gap_mm, "mm"),
    column_gap = unit(col_slice_gap_mm, "mm"),
    use_raster = TRUE, raster_quality = 4
  )

  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
  height_in <- base_height_in + nrow(M) * per_row_height_in
  out_files <- character(0)
  if ("png" %in% tolower(formats)) {
    f <- file.path(out_dir, paste0(out_stem, ".png"))
    png(f, width = width_in, height = height_in, units = "in", res = dpi)
    draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
    dev.off(); out_files <- c(out_files, f)
  }
  if ("pdf" %in% tolower(formats)) {
    f <- file.path(out_dir, paste0(out_stem, ".pdf"))
    pdf(f, width = width_in, height = height_in, useDingbats = FALSE)
    draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
    dev.off(); out_files <- c(out_files, f)
  }
  message("Saved: ", paste(out_files, collapse = " | "))

  if (return_objects) invisible(list(
    matrix = M,
    row_order = rownames(M),
    split_labels = as.character(split_for_ht),
    heatmap = ht
  ))
}

```

```{r, Run Heatmap Function}
#Use without clustering
make_csaw_heatmap_clusterby(
  df           = H3K27me3_CS_Heatmap_K27promTSS_vWT,
  plot_cols    = c("cac1","cac2","ash1"),
  cluster_by   = c("cac1","cac2"),
  collapse_mutants = FALSE,
  fold_cutoff  = NULL,          # derive from the band below
  zero_white_band = 1,          # => loss â‰¤ -1, gain â‰¥ +1; keep in between
  sort_reference = "WT",        # safely ignored if WT col not present
  color_limits = c(-3, 3),
  cluster_cols = FALSE,
  sort_decreasing = FALSE,
  row_slice_gap_mm = 0,
  out_stem = "H3K27me3_vWT_sep_cac1_cac2"
)

make_csaw_heatmap_clusterby(
  df           = H3K27me3_CS_Heatmap_K27promTSS_vInput,
  plot_cols    = c("WT","cac1","cac2","ash1"),
  cluster_by   = c("WT","cac1","cac2"),  # WT included but collapse ignores it when deciding loss/keep/gain
  collapse_mutants = TRUE,               # yields: loss in any (cac1|cac2), kept in all, gain in any
  fold_cutoff  = 1,
  sort_reference = "WT",                 # nice fallback for 'loss in any' rows where both mutants are lost
  clip_negatives_to_zero = FALSE,        # set TRUE if you want strictly non-negative plotting
  colors       = c("white","#006400"),
  color_limits = c(0, NA),
  out_stem = "H3K27me3_vInput_collapse_mutants"
)

```

```{r, plotting HEATMAP w/ RNA-seq data}
#script to make a heatmap w ChIP log2FC data & RNA-seq log2FC data (will use csaw results, which is why i have it here)

#read in log2FC Expression data saved from DESeq for whatever strains you want
cac1RNA= read.csv("../CAF-1_RNA-seq_Analysis/csv_files/cac1_new_ALL.csv", row.names = 1)
cac2RNA= read.csv("../CAF-1_RNA-seq_Analysis/csv_files/cac2_ALL.csv", row.names = 1)
set7RNA= read.csv("../CAF-1_RNA-seq_Analysis/csv_files/set7_ALL.csv", row.names = 1)
#ash1RNA= read.csv("../CAF-1_RNA-seq_Analysis/csv_files/set7_ALL.csv", row.names = 1)

#RNA coloring function for colorbrwer RdBu heatmap
rng <- c(-3, 3)
pal  <- colorRampPalette(rev(brewer.pal(7, "RdBu")))(100)  # includes white in the middle
vals <- seq(rng[1], rng[2], length.out = length(pal))
rna_col_fun <- colorRamp2(vals, pal)

#Plot heatmap with ChIP & RNA-seq log2FC

suppressPackageStartupMessages({
  library(ComplexHeatmap)
  library(circlize)
  library(grid)
})

make_chip_rna_heatmap_simple <- function(
  # --- ChIP inputs ---
  chip_df         = NULL,                 # (legacy) single ChIP df
  chip_cols       = NULL,                 # cols for single df
  chip_list       = NULL,                 # named list of ChIP dfs, e.g. list(K27=df1, K36=df2)
  chip_cols_list  = NULL,                 # named list of col vectors per chip key

  # --- RNA inputs (choose one path) ---
  rna_list        = NULL,                 # named list of RNA dfs; rownames = gene IDs
  rna_matrix      = NULL,                 # NEW: matrix/df with rownames = gene IDs, cols = strains (e.g., z-scores)
  rna_select      = NULL,                 # NEW: character vector of column names to plot from rna_matrix
  rna_colname     = "log2FoldChange",     # used only if rna_list is provided
  rna_missing_fill = 0,                   # NEW: value to use when a gene is missing in RNA (default 0)

  # --- IDs / columns ---
  gene_col        = "gene_id",

  # --- AUTO CLUSTERING (ignored if manual_clusters provided) ---
  cluster_by       = NULL,
  collapse_mutants = FALSE,
  fold_cutoff      = NULL,
  sort_reference   = c("WT"),
  cluster_on_chip  = NULL,

  # --- GLOBAL SORTING (applies unless overridden per cluster) ---
  sort_on          = c("chip","rna"),
  sort_strains     = NULL,
  sort_chip        = NULL,
  sort_decreasing  = TRUE,

  # --- MANUAL CLUSTERS (gene_id-based; list order = heatmap order) ---
  manual_clusters        = NULL,
  manual_labels          = NULL,
  manual_keep_unassigned = TRUE,
  manual_sort            = NULL,           # e.g. list("K36 lost"=list(on="chip", chip="K36", strains=c("cac1","cac2"), decreasing=FALSE))

  # --- visuals (defaults for ALL ChIP panels unless overridden per-chip) ---
  chip_limits    = NULL,
  chip_zero_band = NULL,
  chip_colors    = c("#3B4CC0","white","#B40426"),
  chip_limits_list    = NULL,              # key -> c(min,max)
  chip_zero_band_list = NULL,              # key -> numeric or NULL
  chip_colors_list    = NULL,              # key -> vector or colorRamp2()

  # RNA visuals
  rna_limits     = NULL,               # z-score-friendly default
  rna_zero_band  = NULL,
  rna_colors     = c("blue","white","red"),

  row_gaps_mm    = 0,

  # --- export ---
  out_dir        = NULL,
  file_prefix    = "chip_rna_heatmap",
  save_formats   = c("pdf","png"),
  width_in       = 10,
  height_in      = NULL,
  base_height_in = 1.5,
  per_row_height_in = 0.006,
  dpi            = 300,
  write_plotted_rows = FALSE,
  verbose        = TRUE
){
  `%||%` <- function(a,b) if (!is.null(a)) a else b
  sort_on <- match.arg(sort_on)

  if (is.null(rna_list) && is.null(rna_matrix)) {
    stop("Provide either rna_list or rna_matrix.")
  }

  # ---- normalize ChIP inputs to a named list ----
  .as_named_list <- function(x) {
    if (is.null(x)) return(NULL)
    if (is.list(x) && !is.data.frame(x)) {
      if (is.null(names(x)) || any(names(x) == "")) stop("chip_list must be a *named* list.")
      return(x)
    }
    list(ChIP = x)
  }
  chip_list <- .as_named_list(chip_list %||% chip_df)
  if (is.null(chip_list)) stop("Provide chip_df or chip_list.")

  # ---- intersect genes across *chips only* by gene_id ----
  .genes_in_df <- function(df) as.character(df[[gene_col]])
  chip_common <- Reduce(intersect, lapply(chip_list, .genes_in_df))
  if (length(chip_common) == 0) stop("No overlapping gene IDs across chip inputs using gene_col='", gene_col, "'.")

  # subset each chip df to chip_common (preserve order)
  chip_list <- lapply(chip_list, function(df) df[match(chip_common, df[[gene_col]]), , drop = FALSE])

  # ---- build CHIP matrices for each dataset ----
  # we need strain guesses to pick logFC_* columns
  # get RNA strain names (unprefixed) from whichever RNA path will be used
  rna_strain_names <- {
    if (!is.null(rna_matrix)) {
      if (is.null(colnames(rna_matrix))) stop("rna_matrix must have column names (strain names).")
      if (!is.null(rna_select)) {
        intersect(rna_select, colnames(rna_matrix))
      } else {
        colnames(rna_matrix)
      }
    } else {
      names(rna_list)
    }
  }

  manual_strains <- unique(unlist(lapply(manual_sort %||% list(), function(x) x$strains)))
  guess_base <- unique(c(rna_strain_names %||% character(0),
                         cluster_by %||% character(0),
                         sort_strains %||% character(0),
                         manual_strains %||% character(0)))

  chipMats_score <- list()  # colnames = raw strains ("cac1","cac-1","set-7", etc.)
  chipMats_disp  <- list()  # colnames = "<chipkey>_<strain>" for plotting
  for (ck in names(chip_list)) {
    df <- chip_list[[ck]]
    if (!is.null(chip_cols_list) && !is.null(chip_cols_list[[ck]])) {
      cols <- chip_cols_list[[ck]]
    } else if (!is.null(chip_cols) && length(chip_list) == 1) {
      cols <- chip_cols
    } else {
      cols <- intersect(paste0("logFC_", guess_base), names(df))
      if (!length(cols)) cols <- grep("^logFC_", names(df), value = TRUE)
    }
    if (!length(cols)) stop("No ChIP logFC columns found for chip key '", ck, "'.")
    m <- as.matrix(df[, cols, drop = FALSE])
    rownames(m) <- chip_common
    raw <- sub("^logFC_", "", colnames(m))
    colnames(m) <- raw
    chipMats_score[[ck]] <- m
    mdisp <- m; colnames(mdisp) <- paste0(ck, "_", raw)
    chipMats_disp[[ck]] <- mdisp
  }

  # ---- build RNA matrix (either from list or matrix), aligned to chip_common, fill missing with rna_missing_fill ----
  if (!is.null(rna_matrix)) {
    # select columns
    sel <- if (is.null(rna_select)) colnames(rna_matrix) else intersect(rna_select, colnames(rna_matrix))
    if (!length(sel)) stop("None of rna_select matched columns of rna_matrix.")
    R <- as.matrix(rna_matrix[, sel, drop = FALSE])
    # align rows to chip_common with fill
    rnaMat <- matrix(rna_missing_fill, nrow = length(chip_common), ncol = ncol(R),
                     dimnames = list(chip_common, paste0("RNA_", colnames(R))))
    row_idx <- match(rownames(R), chip_common)
    keep <- which(!is.na(row_idx))
    if (length(keep)) rnaMat[row_idx[keep], seq_along(sel)] <- R[keep, , drop = FALSE]
  } else {
    # rna_list path
    if (!is.list(rna_list) || !length(names(rna_list))) stop("rna_list must be a *named* list of data.frames.")
    strains_rna <- names(rna_list)
    pull_rna <- function(df, genes, col) {
      # robust match + fill
      v <- rep(NA_real_, length(genes)); names(v) <- genes
      m <- match(genes, rownames(df))
      hit <- which(!is.na(m))
      if (length(hit)) v[hit] <- suppressWarnings(as.numeric(df[m[hit], col, drop = TRUE]))
      v
    }
    R <- do.call(cbind, lapply(strains_rna, function(s) pull_rna(rna_list[[s]], chip_common, rna_colname)))
    R[is.na(R)] <- rna_missing_fill
    colnames(R) <- paste0("RNA_", strains_rna)
    rownames(R) <- chip_common
    rnaMat <- R
  }

  # =================== CLUSTER ASSIGNMENT (same as before) ===================
  .genes_from_obj <- function(x) {
    if (is.character(x)) return(unique(as.character(x)))
    if (is.data.frame(x)) {
      cn <- colnames(x); cand <- c(gene_col,"gene_id","gene","Gene","GeneID","gene_name","Name","symbol","V10","V11")
      gcol <- cand[cand %in% cn][1]; if (!length(gcol)) stop("manual_clusters df has no gene column.")
      return(unique(as.character(x[[gcol]])))
    }
    if (methods::is(x, "GRanges")) {
      mc <- S4Vectors::mcols(x); cn <- colnames(mc)
      cand <- c(gene_col,"gene_id","gene","Gene","GeneID","gene_name","Name","symbol","V10","V11")
      gcol <- cand[cand %in% cn][1]; if (!length(gcol)) stop("manual_clusters GRanges has no gene column.")
      return(unique(as.character(mc[[gcol]])))
    }
    stop("Unsupported manual_clusters element class: ", paste(class(x), collapse="/"))
  }

  auto_chip_key <- cluster_on_chip %||% names(chipMats_score)[1]
  orig <- chipMats_score[[auto_chip_key]]
  if (is.null(orig)) stop("Auto clustering chip key '", auto_chip_key, "' not found.")

  cut <- if (is.null(fold_cutoff)) {
    if (!is.null(chip_zero_band)) { if (length(chip_zero_band) == 1) abs(chip_zero_band) else max(abs(chip_zero_band)) }
    else 1
  } else as.numeric(fold_cutoff)

  .order_by <- function(idx, on = sort_on, strains = sort_strains, dec = sort_decreasing, chip_key = sort_chip) {
    if (on == "chip") {
      key <- chip_key %||% names(chipMats_score)[1]
      M   <- chipMats_score[[key]]
      if (is.null(M)) stop("sort_chip key '", key, "' not found.")
      cols <- if (is.null(strains)) colnames(M) else intersect(strains, colnames(M))
      if (!length(cols)) cols <- colnames(M)
      sc <- rowMeans(M[idx, cols, drop = FALSE], na.rm = TRUE)
    } else {
      want <- if (is.null(strains)) colnames(rnaMat) else paste0("RNA_", strains)
      cols <- intersect(want, colnames(rnaMat)); if (!length(cols)) cols <- colnames(rnaMat)
      sc <- rowMeans(rnaMat[idx, cols, drop = FALSE], na.rm = TRUE)
    }
    order(sc, decreasing = dec, na.last = TRUE)
  }

  .order_by_manual <- function(idx, cl_label) {
    if (!is.null(manual_sort) && !is.null(manual_sort[[cl_label]])) {
      spec <- manual_sort[[cl_label]]
      on   <- spec$on  %||% sort_on
      st   <- spec$strains %||% sort_strains
      dec  <- if (!is.null(spec$decreasing)) isTRUE(spec$decreasing) else sort_decreasing
      ck   <- spec$chip %||% sort_chip
      return(.order_by(idx, on = on, strains = st, dec = dec, chip_key = ck))
    } else {
      return(.order_by(idx, on = sort_on, strains = sort_strains, dec = sort_decreasing, chip_key = sort_chip))
    }
  }

  use_manual <- !is.null(manual_clusters) && length(manual_clusters) > 0
  genes <- chip_common

  if (use_manual) {
    if (is.null(names(manual_clusters))) names(manual_clusters) <- paste0("cluster_", seq_along(manual_clusters))
    labels <- manual_labels %||% names(manual_clusters)

    cl_vec <- rep(NA_character_, length(genes))
    for (i in seq_along(manual_clusters)) {
      gset <- .genes_from_obj(manual_clusters[[i]])
      hit <- which(is.na(cl_vec) & genes %in% gset)
      if (length(hit)) cl_vec[hit] <- labels[i]
      if (verbose) message(sprintf("Manual cluster '%s': matched %d rows", labels[i], length(hit)))
    }

    if (isTRUE(manual_keep_unassigned)) {
      cl_vec[is.na(cl_vec)] <- "other"
      cluster_levels <- c(labels, "other")
    } else {
      keep <- !is.na(cl_vec)
      genes <- genes[keep]; cl_vec <- cl_vec[keep]
      chipMats_score <- lapply(chipMats_score, function(m) m[keep, , drop = FALSE])
      chipMats_disp  <- lapply(chipMats_disp,  function(m) m[keep, , drop = FALSE])
      rnaMat <- rnaMat[keep, , drop = FALSE]
      if (verbose) message("Dropped unassigned rows: ", sum(!keep))
      cluster_levels <- labels
    }
    cl_split <- factor(cl_vec, levels = cluster_levels, ordered = TRUE)

    ord <- integer(0)
    for (cl in levels(cl_split)) {
      idx <- which(cl_split == cl); if (!length(idx)) next
      ord <- c(ord, idx[.order_by_manual(idx, cl)])
    }
    chipMats_score <- lapply(chipMats_score, function(m) m[ord, , drop = FALSE])
    chipMats_disp  <- lapply(chipMats_disp,  function(m) m[ord, , drop = FALSE])
    rnaMat   <- rnaMat[ord, , drop = FALSE]
    cl_split <- cl_split[ord]

  } else {
    if (is.null(cluster_by) || length(cluster_by) == 0) stop("Auto mode requires cluster_by.")
    state_for <- function(M, strains) {
      vals <- M[, strains, drop = FALSE]
      d <- matrix(0L, nrow(vals), ncol(vals), dimnames = dimnames(vals))
      d[vals <= -abs(cut)] <- -1L
      d[vals >=  abs(cut)] <-  1L
      d
    }
    Mkey <- chipMats_score[[auto_chip_key]]
    if (is.null(Mkey)) stop("Auto clustering chip key not found: ", auto_chip_key)
    state <- state_for(Mkey, cluster_by)

    if (!collapse_mutants) {
      if (length(cluster_by) != 2L) stop("separate mode requires exactly two cluster_by strains.")
      a <- cluster_by[1]; b <- cluster_by[2]
      sA <- state[, a]; sB <- state[, b]
      lab <- rep("other", length(genes))
      lab[sA == -1L & sB == -1L] <- sprintf("loss in both (%s & %s)", a, b)
      lab[sA == -1L & sB ==  0L] <- sprintf("loss in %s only", a)
      lab[sA ==  0L & sB == -1L] <- sprintf("loss in %s only", b)
      lab[sA ==  0L & sB ==  0L] <- sprintf("kept in both (%s & %s)", a, b)
      cluster_levels <- c(sprintf("loss in both (%s & %s)", a, b),
                          sprintf("loss in %s only", a),
                          sprintf("loss in %s only", b),
                          sprintf("kept in both (%s & %s)", a, b),
                          "other")
    } else {
      targets <- setdiff(cluster_by, "WT"); if (!length(targets)) targets <- cluster_by
      loss_any <- apply(state[, targets, drop = FALSE] == -1L, 1, any, na.rm = TRUE)
      keep_all <- apply(state[, targets, drop = FALSE] ==  0L, 1, all, na.rm = TRUE)
      gain_any <- apply(state[, targets, drop = FALSE] ==  1L, 1, any, na.rm = TRUE)
      lab <- rep("other", length(genes))
      lab[loss_any] <- sprintf("loss in any (%s)", paste(targets, collapse=" | "))
      lab[!loss_any & keep_all] <- sprintf("kept in all (%s)", paste(targets, collapse=" & "))
      lab[!loss_any & !keep_all & gain_any] <- sprintf("gain in any (%s)", paste(targets, collapse=" | "))
      cluster_levels <- c(sprintf("loss in any (%s)", paste(targets, collapse=" | ")),
                          sprintf("kept in all (%s)", paste(targets, collapse=" & ")),
                          sprintf("gain in any (%s)", paste(targets, collapse=" | ")),
                          "other")
    }
    cl_split <- factor(lab, levels = cluster_levels, ordered = TRUE)

    ord <- integer(0)
    for (cl in levels(cl_split)) {
      idx <- which(cl_split == cl); if (!length(idx)) next
      ord <- c(ord, idx[.order_by(idx, on = sort_on, strains = sort_strains, dec = sort_decreasing, chip_key = sort_chip)])
    }
    chipMats_score <- lapply(chipMats_score, function(m) m[ord, , drop = FALSE])
    chipMats_disp  <- lapply(chipMats_disp,  function(m) m[ord, , drop = FALSE])
    rnaMat   <- rnaMat[ord, , drop = FALSE]
    cl_split <- cl_split[ord]
  }

  # ---- color helpers ----
  .calc_limits <- function(M, lims) {
    if (is.null(lims)) return(range(M, na.rm = TRUE))
    L <- as.numeric(lims); if (length(L) != 2) stop("limits must be length-2.")
    if (is.na(L[1])) L[1] <- min(M, na.rm = TRUE)
    if (is.na(L[2])) L[2] <- max(M, na.rm = TRUE)
    L
  }
  .mk_col_fun <- function(lims, band, cols){
    # cols may be a vector (e.g., c("white","#00441B")) or a colorRamp2 function
    if (is.function(cols)) return(cols)

    # helper to pick endpoint colors
    low_col  <- cols[1]
    high_col <- cols[length(cols)]

    if (!is.null(band)) {
      b <- abs(band)[1]

      if (lims[1] < 0 && lims[2] > 0) {
        # Diverging: insert a white band around 0 of width 2*b
        circlize::colorRamp2(
          c(lims[1], -b, 0, b, lims[2]),
          c(low_col, "white", "white", "white", high_col)
        )
      } else {
        # Non-diverging (e.g., 0..X): enforce a flat white floor up to 'b'
        # Clamp band to [lims[1], lims[2]]
        bb <- max(lims[1], min(b, lims[2]))
        if (bb <= lims[1]) {
          # band at/below lower limit -> plain sequential
          circlize::colorRamp2(c(lims[1], lims[2]), c(low_col, high_col))
        } else if (bb >= lims[2]) {
          # everything in the band -> all white (degenerate but defined)
          circlize::colorRamp2(c(lims[1], lims[2]), c("white","white"))
        } else {
          # [lims[1], bb] stays white; gradient from bb -> lims[2]
          circlize::colorRamp2(c(lims[1], bb, lims[2]),
                               c("white", "white", high_col))
        }
      }
    } else {
      # No band at all â†’ standard behavior
      if (lims[1] < 0 && lims[2] > 0 && length(cols) >= 3) {
        circlize::colorRamp2(c(lims[1], 0, lims[2]),
                             c(cols[1], cols[2], high_col))
      } else {
        circlize::colorRamp2(c(lims[1], lims[2]), c(low_col, high_col))
      }
    }
  }


  # ---- build Heatmaps: per-chip ----
  chip_hts <- list()
  for (ck in names(chipMats_disp)) {
    Mraw  <- chipMats_disp[[ck]]
    lims  <- .calc_limits(Mraw, (chip_limits_list %||% list())[[ck]] %||% chip_limits)
    band  <- (chip_zero_band_list %||% list())[[ck]] %||% chip_zero_band
    cols  <- (chip_colors_list    %||% list())[[ck]] %||% chip_colors
    colf  <- .mk_col_fun(lims, band, cols)

    Mshow <- pmin(pmax(Mraw, lims[1]), lims[2])
    chip_hts[[ck]] <- Heatmap(
      Mshow, name = paste0(ck, " ChIP log2FC"), col = colf,
      cluster_rows = FALSE, cluster_columns = FALSE, show_row_names = FALSE,
      row_split = cl_split, row_gap = unit(row_gaps_mm, "mm")
    )
  }

  # RNA panel (z-scores or whatever you feed)
  rlims <- .calc_limits(rnaMat, rna_limits)
  rcolf <- .mk_col_fun(rlims, rna_zero_band, rna_colors)
  rna_show <- pmin(pmax(rnaMat, rlims[1]), rlims[2])
  ht_rna <- Heatmap(
    rna_show,  name = "RNA (scores)",  col = rcolf, na_col = "white",
    cluster_rows = FALSE, cluster_columns = FALSE, show_row_names = FALSE,
    row_split = cl_split, row_gap = unit(row_gaps_mm, "mm")
  )

  # concatenate: all ChIP panels then RNA
  ht_all <- Reduce(`+`, c(chip_hts, list(ht_rna)))

  # ---- plotted rows table ----
  plotted_rows <- {
    chip_df_all <- do.call(cbind, chipMats_disp)
    data.frame(
      order_idx = seq_len(nrow(chip_df_all)),
      gene      = rownames(chip_df_all),
      cluster   = as.character(cl_split),
      chip_df_all,
      rnaMat,
      check.names = FALSE
    )
  }

  # ---- draw / save ----
  n_rows <- nrow(plotted_rows)
  eff_h  <- if (is.null(height_in)) base_height_in + n_rows * per_row_height_in else height_in

  if (!is.null(out_dir)) {
    dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
    if (isTRUE(write_plotted_rows)) {
      write.csv(plotted_rows, file.path(out_dir, paste0(file_prefix, "_plotted_rows.csv")), row.names = FALSE)
    }
    fmts <- tolower(save_formats)
    if ("pdf" %in% fmts) {
      pdf(file.path(out_dir, paste0(file_prefix, ".pdf")), width = width_in, height = eff_h, useDingbats = FALSE)
      draw(ht_all, heatmap_legend_side = "right"); dev.off()
    }
    if ("png" %in% fmts) {
      png(file.path(out_dir, paste0(file_prefix, ".png")), width = width_in, height = eff_h, units = "in", res = dpi)
      draw(ht_all, heatmap_legend_side = "right"); dev.off()
    }
  }

  draw(ht_all, heatmap_legend_side = "right")
  invisible(list(
    chip_matrices     = chipMats_disp,      # plotted (prefixed)
    chip_matrices_raw = chipMats_score,     # raw (for scoring)
    rna_matrix        = rnaMat,
    clusters          = cl_split,
    genes_plotted     = rownames(rnaMat),
    plotted_rows      = plotted_rows
  ))
}

```

```{r, use ChIP-RNA heatmap function}

#manual clustering
##vWT
out <- make_chip_rna_heatmap_simple(
  chip_list = list(
    K27 = H3K27me3_CS_Results_K27promTSS_vWT,
    K36 = H3K36me3_Results_K27promTSS_vWT
  ),
  chip_cols_list = list(
    K27 = c("logFC_cac1","logFC_cac2","logFC_set7"),
    K36 = c("logFC_cac1","logFC_cac2","logFC_set7")
  ),
  rna_list  = list(cac1 = cac1RNA, cac2 = cac2RNA, set7 = set7RNA),
  gene_col  = "gene_id",
  manual_clusters = list(
    K36_lost       = K36lost,
    K27_lost_only  = K27lost_only,
    K27_K36retain  = K27_K36retain
  ),
  manual_labels = c("K36 lost","K27 lost only","K27&K36 retain"),
  sort_on         = "chip",
  sort_chip       = "K36",
  sort_strains    = c("cac1","cac2"),
  sort_decreasing = FALSE,  # negatives on top
  manual_sort = list(
    "K36 lost"        = list(on="chip", chip="K36", strains=c("cac1","cac2"), decreasing=FALSE),
    "K27 lost only"   = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=FALSE),
    "K27&K36 retain"  = list(on="rna", strains=c("cac1","cac2","set7"), decreasing=TRUE)
  ),
  chip_limits = c(-2,2),
  rna_limits  = c(-6,6),
  chip_zero_band = 1,
  rna_zero_band  = 1.5,
  row_gaps_mm = 0,
  out_dir = "csaw_heatmaps",
  file_prefix = "K27_K36_vWT_RNA_multiPanel",
  save_formats = c("pdf","png"),
  width_in = 12,
  dpi = 300,
  write_plotted_rows = TRUE
)

##vInput
out <- make_chip_rna_heatmap_simple(
  chip_list = list(
    K27 = H3K27me3_CS_Results_K27promTSS_vInput,
    K36 = H3K36me3_Results_K27promTSS_vInput
  ),
  chip_cols_list = list(
    K27 = c("logFC_cac1","logFC_cac2","logFC_set7"),
    K36 = c("logFC_cac1","logFC_cac2","logFC_set7")
  ),
  rna_list  = list(cac1 = cac1RNA, cac2 = cac2RNA, set7 = set7RNA),
  gene_col  = "gene_id",
  manual_clusters = list(
    K36_lost       = K36lost,
    K27_lost_only  = K27lost_only,
    K27_K36retain  = K27_K36retain
  ),
  manual_labels = c("K36 lost","K27 lost only","K27+K36 retain"),
  manual_sort = list(
    "K36 lost"       = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=TRUE),
    "K27 lost only"  = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=TRUE),
    "K27+K36 retain" = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=TRUE)
  ),
  chip_colors_list = list(
    K27 = c("white","#00441B"),
    K36 = c("white","#a65628")
  ),
  chip_limits_list = list(
    K27 = c(0, 5),
    K36 = c(0, 2)
  ),
  chip_zero_band = 1,
  rna_limits = c(-6,6),
  rna_zero_band = 1.5,
  rna_colors = c("blue","white","red"),
  row_gaps_mm = 0,
  out_dir = "csaw_heatmaps",
  file_prefix = "K27_K36_RNA_multicolor",
  save_formats = c("pdf","png"),
  width_in = 12,
  dpi = 300,
  write_plotted_rows = TRUE
)

#Using z-score table for RNA-seq
# z-score table like your GenesWithChanges (rows = gene IDs, cols = strains)
rna_cols <- c("cac-1","cac-2","set-7")  # (match column names in your z-score df)

out <- make_chip_rna_heatmap_simple(
  chip_list = list(
    K27 = H3K27me3_CS_Results_K27promTSS_vInput,
    K36 = H3K36me3_Results_K27promTSS_vInput
  ),
  chip_cols_list = list(
    K27 = c("logFC_WT","logFC_cac1","logFC_cac2","logFC_set7"),
    K36 = c("logFC_WT","logFC_cac1","logFC_cac2","logFC_set7")
  ),
  rna_matrix = rna_z,
  rna_select = rna_cols,          # choose which columns to show
  rna_missing_fill = 0,           # missing genes -> 0
  gene_col  = "gene_id",
  manual_clusters = list(
    K36_lost       = K36lost,       # new name = df name (if not renamed with labels)
    K27_lost_only  = K27lost_only,
    K27_K36retain  = K27_K36retain
  ),
  manual_labels = c("K36 lost","K27 lost only","K27&K36 retain"),
  manual_sort = list(
    "K36 lost"       = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=TRUE),
    "K27 lost only"  = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=TRUE),
    "K27&K36 retain" = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=TRUE)
  ),
  chip_colors_list = list(
    K27 = c("white","#00441B"),
    K36 = c("white","#a65628")
  ),
  chip_limits_list = list(
    K27 = c(0, 5),
    K36 = c(0, 2)
  ),
  chip_zero_band = 1,
  rna_colors = rna_col_fun,
  row_gaps_mm = 0,
  out_dir = "csaw_heatmaps",
  file_prefix = "K27_K36_zRNA",
  save_formats = c("pdf","png"),
  width_in = 12,
  dpi = 300,
  write_plotted_rows = TRUE
)


manual_sort = list(
    "K36 lost"       = list(on="chip", chip="K36", strains=c("cac1","cac2"), decreasing=FALSE),
    "K27 lost only"  = list(on="chip", chip="K27", strains=c("cac1","cac2"), decreasing=FALSE),
    "K27&K36 retain" = list(on="chip",  strains=c("cac1","cac2","set7"), decreasing=FALSE)
  ),
  chip_colors_list = list(
    K27 = c("darkblue","darkred"),
    K36 = c("darkblue","darkred")
  ),
  chip_limits_list = list(
    K27 = c(-2, 2),
    K36 = c(-2, 2)
  ),

#auto-clustering
out <- make_chip_rna_heatmap_simple(
  chip_df   = H3K36me3_Results_K27promTSS_vWT,
  rna_list  = list(cac1 = cac1RNA, cac2 = cac2RNA, set7 = set7RNA),
  gene_col  = "gene_id",
  chip_cols = c("logFC_cac1","logFC_cac2","logFC_set7"),
  cluster_by       = c("cac1","cac2"),
  collapse_mutants = FALSE,
  fold_cutoff      = NULL,          # <- uses chip_zero_band below
  chip_zero_band   = 1,             # |log2FC| < 1 treated as "kept"
  sort_reference   = "WT",          # ignored if absent
  sort_decreasing  = FALSE,         # most negative at the top
  chip_limits = c(-2,2),
  rna_limits  = c(-6,6),
  rna_zero_band = 1.5,
  row_gaps_mm = 0,
  out_dir = "csaw_heatmaps",
  file_prefix = "H3K36me3_vs_RNA_cac1cac2_sep",
  save_formats = c("pdf","png"),
  width_in = 8,
  dpi = 300
)


out <- make_chip_rna_heatmap(
  chip_df   = H3K36me3_Results_K27promTSS_vWT,
  rna_list  = list(cac1 = cac1RNA, cac2 = cac2RNA),
  clusters_df = NULL,
  gene_col  = "V10",
  chip_cols = c("logFC_cac1","logFC_cac2"),
  sort_strains = c("cac1","cac2"),
  chip_limits = c(-2,2),
  rna_limits  = c(-6,6),
  chip_zero_band = 1,
  rna_zero_band  = 1,
  row_gaps_mm = 0,
  out_dir = "csaw_heatmaps",
  file_prefix = "H3K36me3_vs_RNA_CAF_sorted",
  save_formats = c("pdf","png"),
  width_in = 8,
  dpi = 300
)

```


```{r, ChIP vs. RNA scatter plot code}
#Use this to make scatterplots of ChIP-seq signal over genes vs. their RNA-seq expression values or another modifcation
## Would probably only try to use with region mode

suppressPackageStartupMessages({
  library(ggplot2)
  library(dplyr)
  library(stringr)
  library(tibble)
})

# Flexible scatter: ChIP vs RNA  OR  ChIP vs ChIP (with skew coloring)
chip_scatter_flex <- function(
  mode = c("chip_vs_rna","chip_vs_chip"),

  # --- inputs shared / aligned by gene id ---
  gene_col       = "V10",          # gene id column inside ChIP dfs

  # X axis (ChIP set A)
  chip_df_x,                        # ChIP df for X (e.g., H3K27me3 promoters)
  strain_x,                         # e.g., "cac1"
  chip_col_x     = NULL,            # auto-detect "logFC_<strain_x>"

  # Y axis (depends on mode)
  # mode="chip_vs_rna"
  rna_df         = NULL,            # rownames = gene IDs, has rna_col
  rna_col        = "log2FoldChange",
  # mode="chip_vs_chip"
  chip_df_y      = NULL,            # second ChIP df (e.g., H3K36me3 promoters)
  strain_y       = NULL,            # strain for Y
  chip_col_y     = NULL,            # auto-detect "logFC_<strain_y>"

  # --- coloring ---
  # ChIP vs RNA: color by RNA magnitude
  up_thresh      =  2,
  down_thresh    = -2,
  rna_colors_map = c(up = "red", down = "blue", ns = "gray50"),
  rna_legend_title = "RNA log2FC group",

  # ChIP vs ChIP: color by skew (difference) between modifications
  chip_diff_thresh = 1,             # threshold on (x - y) in log2 space
  chip_colors_map  = c(x_dom = "#d62728", y_dom = "#1f77b4", similar = "gray70"),
  chip_legend_title = "Skew (X vs Y)",

  # stats / fit
  cor_method     = c("pearson","spearman"),
  add_lm         = TRUE,
  fit_global     = TRUE,
  fit_color      = "black",
  fit_linetype   = "dashed",
  fit_se         = FALSE,

  # aesthetics
  point_alpha    = 0.75,
  point_size     = 1.6,

  # labels
  xlab           = NULL,
  ylab           = NULL,
  title          = NULL,
  chip_x_label   = NULL,            # e.g., "H3K27me3"
  chip_y_label   = NULL,            # e.g., "H3K36me3"

  # axes (no data drop)
  xlim           = NULL,
  ylim           = NULL,

  # hygiene
  drop_na        = TRUE,

  # output (same style as your heatmap helper)
  out_dir        = NULL,
  file_prefix    = NULL,
  save_formats   = c("pdf","png"),
  width_in       = 12,
  height_in      = 9,
  dpi            = 600
) {
  `%||%` <- function(a,b) if (!is.null(a)) a else b
  mode <- match.arg(mode)
  cor_method <- match.arg(cor_method)

  # helper: pick column
  pick_chip_col <- function(df, strain) {
    pref <- paste0("logFC_",  strain)
    fall <- paste0("log2FC_", strain)
    if (pref %in% names(df)) return(pref)
    if (fall %in% names(df)) return(fall)
    pats <- paste0("^log2?fc[._-]?", tolower(strain))
    hits <- names(df)[str_detect(tolower(names(df)), pats)]
    if (!length(hits)) stop("Could not find a ChIP column for strain '", strain, "'. Expected '", pref, "'.")
    hits[1]
  }

  # X: ChIP A
  stopifnot(gene_col %in% names(chip_df_x))
  if (is.null(chip_col_x)) chip_col_x <- pick_chip_col(chip_df_x, strain_x)
  stopifnot(chip_col_x %in% names(chip_df_x))
  x_tbl <- chip_df_x %>%
    transmute(GeneID = .data[[gene_col]], x = suppressWarnings(as.numeric(.data[[chip_col_x]])))

  # Y: depends on mode
  if (mode == "chip_vs_rna") {
    if (is.null(rna_df)) stop("Provide rna_df for mode='chip_vs_rna'.")
    if (is.null(rownames(rna_df))) stop("rna_df must have rownames as gene IDs.")
    if (!rna_col %in% colnames(rna_df)) stop("rna_col '", rna_col, "' not found in rna_df.")
    y_tbl <- rna_df %>%
      as.data.frame() %>%
      rownames_to_column("GeneID") %>%
      transmute(GeneID, y = suppressWarnings(as.numeric(.data[[rna_col]])))
  } else {
    if (is.null(chip_df_y) || is.null(strain_y)) {
      stop("Provide chip_df_y and strain_y for mode='chip_vs_chip'.")
    }
    stopifnot(gene_col %in% names(chip_df_y))
    if (is.null(chip_col_y)) chip_col_y <- pick_chip_col(chip_df_y, strain_y)
    stopifnot(chip_col_y %in% names(chip_df_y))
    y_tbl <- chip_df_y %>%
      transmute(GeneID = .data[[gene_col]], y = suppressWarnings(as.numeric(.data[[chip_col_y]])))
  }

  # align and clean
  plot_df <- inner_join(x_tbl, y_tbl, by = "GeneID")
  if (isTRUE(drop_na)) plot_df <- filter(plot_df, is.finite(x), is.finite(y))
  if (nrow(plot_df) < 3) stop("Not enough overlapping genes with finite values to plot.")

  # color grouping
  if (mode == "chip_vs_rna") {
    plot_df <- mutate(plot_df,
      color_group = case_when(
        y >  up_thresh   ~ "up",
        y <  down_thresh ~ "down",
        TRUE             ~ "ns"
      )
    )
    col_vals <- setNames(as.character(rna_colors_map[c("up","down","ns")]), c("up","down","ns"))
    legend_title <- rna_legend_title
  } else {
    # skew by difference (x - y) ~ log2 ratio x/y
    plot_df <- mutate(plot_df,
      diff_xy = x - y,
      color_group = case_when(
        diff_xy >=  chip_diff_thresh ~ "x_dom",
        diff_xy <= -chip_diff_thresh ~ "y_dom",
        TRUE                         ~ "similar"
      )
    )
    col_vals <- setNames(as.character(chip_colors_map[c("x_dom","y_dom","similar")]),
                         c("x_dom","y_dom","similar"))
    legend_title <- chip_legend_title
  }

  # stats
  ct   <- suppressWarnings(cor.test(plot_df$x, plot_df$y, method = cor_method))
  r2_s <- sprintf("%.2f", unname(ct$estimate)^2)  # always 2 decimals
  pval <- signif(ct$p.value, 3)

  # labels & title
  x_comp <- chip_x_label %||% paste0("ChIP (", strain_x, ")")
  if (mode == "chip_vs_rna") {
    y_comp <- "RNA"
  } else {
    y_comp <- chip_y_label %||% paste0("ChIP (", strain_y, ")")
  }
  if (is.null(xlab)) xlab <- paste0(x_comp, " log2FC")
  if (is.null(ylab)) ylab <- paste0(y_comp, " log2FC")
  if (is.null(title)) {
    left  <- chip_x_label %||% paste0("ChIP-", strain_x)
    right <- if (mode == "chip_vs_rna") "RNA" else (chip_y_label %||% paste0("ChIP-", strain_y))
    title <- paste0(left, " vs ", right)
  }

  # annotation
  xr <- range(plot_df$x, na.rm = TRUE); yr <- range(plot_df$y, na.rm = TRUE)
  x_anno <- xr[1] + 0.02 * diff(xr); y_anno <- yr[2] - 0.05 * diff(yr)
  anno_txt <- paste0("RÂ² = ", r2_s, ", p = ", pval)

  # plot
  p <- ggplot(plot_df, aes(x, y, color = color_group)) +
    geom_point(alpha = point_alpha, size = point_size) +
    scale_color_manual(values = col_vals, name = legend_title) +
    theme_minimal(base_size = 12) +
    labs(x = xlab, y = ylab, title = title) +
    annotate("text", x = x_anno, y = y_anno, label = anno_txt, hjust = 0, size = 4)

  # regression line (global by default)
  if (isTRUE(add_lm) && isTRUE(fit_global)) {
    p <- p + geom_smooth(
      data = plot_df, aes(x, y),
      method = "lm", se = fit_se,
      color = fit_color, linetype = fit_linetype,
      inherit.aes = FALSE
    )
  } else if (isTRUE(add_lm)) {
    p <- p + geom_smooth(method = "lm", se = fit_se, linetype = fit_linetype)
  }

  if (!is.null(xlim) || !is.null(ylim)) p <- p + coord_cartesian(xlim = xlim, ylim = ylim, expand = TRUE)

  # save
  saved <- character(0)
  if (!is.null(out_dir)) {
    dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
    default_stem <- if (mode == "chip_vs_rna") {
      paste0("chip", strain_x, "_vs_rna")
    } else {
      paste0("chip", strain_x, "_vs_chip", strain_y)
    }
    stem <- file_prefix %||% default_stem
    fmts <- tolower(save_formats)
    if ("pdf" %in% fmts) {
      f <- file.path(out_dir, paste0(stem, ".pdf"))
      ggsave(f, plot = p, width = width_in, height = height_in, units = "in", dpi = dpi)
      saved <- c(saved, f)
    }
    if ("png" %in% fmts) {
      f <- file.path(out_dir, paste0(stem, ".png"))
      ggsave(f, plot = p, width = width_in, height = height_in, units = "in", dpi = dpi)
      saved <- c(saved, f)
    }
  }

  invisible(list(
    data  = plot_df,   # GeneID, x, y, (diff_xy), color_group
    cor   = list(r = unname(ct$estimate), r2 = as.numeric(r2_s), p = ct$p.value, method = cor_method),
    gg    = p,
    saved = saved,
    cols  = list(chip_col_x = chip_col_x, chip_col_y = chip_col_y, rna_col = rna_col, mode = mode)
  ))
}

```

```{r, use scatter plot function}

#Example Use (ChIP vs RNA)
out <- chip_scatter_flex(
  mode        = "chip_vs_rna",
  chip_df_x   = Kac_Results_K27promTSS_vWT,  # X = H3K36me3
  strain_x    = "cac1",
  rna_df      = cac1RNA,                          # RNA for cac1
  up_thresh      =  1.5,
  down_thresh    = -1.5,
  chip_x_label = "Kac",                      # label in axes/title
  out_dir     = "scatter_outputs",
  file_prefix = "Kac_K27promTSS_vs_RNA_cac1",
  width_in    = 12, height_in = 9, dpi = 600
)
out$gg


#Example Use (ChIP vs ChIP)
out <- chip_scatter_flex(
  mode        = "chip_vs_chip",
  chip_df_x   = H3K36me3_Results_K27genes_proms_vWT,  # X = H3K27me3
  strain_x    = "cac1",
  chip_df_y   = Kac_Results_K27genes_proms_vWT,  # Y = H3K36me3
  strain_y    = "cac1",
  chip_x_label = "H3K36me3",
  chip_y_label = "Kac",
  chip_diff_thresh = 1,   # needs â‰¥1 log2 unit advantage to be called dominant
  chip_colors_map  = c(x_dom = "#a65628", y_dom = "#cab2d6", similar = "gray70"),
  chip_legend_title = "Skew (K36 vs Kac)",
  out_dir     = "scatter_outputs",
  file_prefix = "H3K27me3_vs_Kac_cac1_promoters_genes",
  width_in    = 12, height_in = 9, dpi = 600
)
out$gg


#View what your plotting
View(out$data)  

```

```{r, function to make bed files from windowCounts}
#This function will utilize enrichment calls from windowCounts to make a bed file with significantly enriched regions for a desired modification. You will feed in a data frame obtained from the analysis function, which will already contain enrichment filtered for significance (FDR &/or p-value). This function will then merge regions that neighbor each other (i.e. chromosome 1 bp 600-899 will merge with chromosome 1 bp 900-1199 if they are both present in the df), and this will create a "peak-call" like bed file with all enriched regions. It will so this by extracting the chromosome, start, and end values from the row name of the df and make it 3 separate columns, characteristic of a bed/peak call file. it will iterate across each strain (column) in the df. you can also set a threshold for size of the fragment to be included in the df to avoid interspersed small fragments (which are likely not real enrichment). For example, a threshold set to 1000 bp would not include any fragments (post-merge) below that size (i.e. at least 4 300 bp windows will have to be merged to create a frag size large enough to be included in the bed)

# Make BED-like "peak calls" from a masked heatmap df (e.g., *_Heatmap_*_vInput)
# - Expects rownames like "chrom.start.end" (we robustly parse even if chrom has dots)
# - For EACH strain column (logFC_*):
#     * keeps rows by sign (positive/negative/any) and minimum absolute value
#     * merges abutting windows (control max inter-window gap in bp)
#     * drops merged fragments smaller than min_width_bp
# - Writes one .bed per strain (3-column BED: chrom, start(0-based), end)
# - Returns a named list of data.frames invisibly
# - WINDOW mode: optional merging of nearby windows (gap <= max_gap_bp) then min-width filter
# - REGION mode: no window merging and no min-width filter (keeps your predefined regions)

suppressPackageStartupMessages({
  requireNamespace("GenomicRanges", quietly = TRUE)
  requireNamespace("IRanges",        quietly = TRUE)
})

heatmap_to_bed_peaks <- function(
  hm_df,
  out_dir,
  prefix,
  mode              = c("window","region"),
  direction         = c("positive","nonzero","negative"),
  min_value         = 0,
  merge_windows     = TRUE,              # (window mode only)
  max_gap_bp        = 0,                 # merge gaps <= this (window mode)
  min_width_bp      = 0,                 # drop merged blocks < this (window mode)
  zero_based        = TRUE,              # BED writing: 0-based starts
  write_empty_files = FALSE,
  create_dataframes = TRUE,              # create *_BED objects in .GlobalEnv

  # ---- Restore original gene-matching logic ----
  # The region set used to build hm_df (e.g., regions$K27promTSS), with coords & gene IDs.
  source_regions_df        = NULL,       # REQUIRED if promote_to_full_genes=TRUE
  source_key_cols          = c("V1","V2","V3"),  # chr,start,end in source_regions_df
  source_gene_col          = "V10",      # gene ID in source_regions_df

  # Promote to full genes by subsetting this "universe" (e.g., regions$allgenes) via gene IDs
  promote_to_full_genes    = FALSE,
  universe_df              = NULL,       # REQUIRED if promote_to_full_genes=TRUE
  universe_gene_col        = "V10",      # gene ID column in universe_df
  universe_label           = "genes",
  universe_is_zero_based   = FALSE,      # how universe_df coords are stored

  # Optional string to append in filenames (e.g., "vInput" or "vWT")
  file_norm_tag            = NULL
) {
  mode      <- match.arg(mode)
  direction <- match.arg(direction)

  if (!is.data.frame(hm_df))
    stop("hm_df must be a data.frame with rownames like 'chr.start.end'.")

  rn <- rownames(hm_df)
  if (is.null(rn) || anyNA(rn))
    stop("hm_df must have non-NA rownames like 'chr.start.end'.")

  # Parse rownames robustly: take last two dot fields as start/end (chr can contain dots)
  m  <- regexec("^(.+)\\.([0-9]+)\\.([0-9]+)$", rn)
  mm <- regmatches(rn, m)
  bad <- vapply(mm, length, integer(1L)) != 4L
  if (any(bad)) {
    stop("Could not parse some rownames into chr.start.end. Example bad rowname: ",
         rn[which(bad)[1L]])
  }
  chr   <- vapply(mm, `[`, "", 2L)
  start <- as.integer(vapply(mm, `[`, "", 3L))
  end   <- as.integer(vapply(mm, `[`, "", 4L))

  base_gr <- GenomicRanges::GRanges(
    seqnames = chr,
    ranges   = IRanges::IRanges(start = start, end = end)
  )

  # logFC columns per strain
  lfc_cols <- grep("^logFC_", colnames(hm_df), value = TRUE)
  if (!length(lfc_cols))
    stop("No columns named like 'logFC_*' found in hm_df.")

  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # Helper to build the file/variable stem
  .stem <- function(strain, is_universe = FALSE) {
    cut_tag <- if (!is.null(min_value) && !isTRUE(is.na(min_value)) && min_value != 0)
      paste0("_log2FC_", as.character(min_value)) else ""
    norm_tag <- if (!is.null(file_norm_tag) && nzchar(file_norm_tag))
      paste0("_", file_norm_tag) else ""
    suffix <- if (is_universe) paste0("_", universe_label) else ""
    paste0(prefix, cut_tag, norm_tag, "_", strain, suffix)
  }

  # Key string for hm_df rows
  hm_key <- paste(chr, start, end, sep = ".")

  # If we will promote to full genes, prepare a lookup from the ORIGINAL region set
  if (isTRUE(promote_to_full_genes)) {
    if (is.null(source_regions_df))
      stop("promote_to_full_genes=TRUE requires source_regions_df (original region set).")
    if (is.null(universe_df))
      stop("promote_to_full_genes=TRUE requires universe_df (e.g., regions$allgenes).")

    # Build key for the source region set to recover gene IDs by exact coord match
    if (!all(source_key_cols %in% names(source_regions_df)))
      stop("source_key_cols not all present in source_regions_df.")
    if (!source_gene_col %in% names(source_regions_df))
      stop("source_gene_col not found in source_regions_df.")

    src_key <- paste(source_regions_df[[source_key_cols[1]]],
                     source_regions_df[[source_key_cols[2]]],
                     source_regions_df[[source_key_cols[3]]], sep = ".")
    src_gene <- as.character(source_regions_df[[source_gene_col]])
    # fast lookup: key -> gene
    # A region can map to exactly one gene in your promoter/TSS set; if duplicated, keep first.
    key2gene <- tapply(src_gene, src_key, function(x) x[1])
  }

  # Output containers
  out_list_ranges <- stats::setNames(vector("list", length(lfc_cols)),
                                     sub("^logFC_", "", lfc_cols))
  out_list_genes  <- if (isTRUE(promote_to_full_genes))
    stats::setNames(vector("list", length(lfc_cols)), sub("^logFC_", "", lfc_cols)) else NULL

  for (lc in lfc_cols) {
    strain <- sub("^logFC_", "", lc)
    vals <- hm_df[[lc]]

    keep <- switch(
      direction,
      positive = vals >  min_value,
      negative = vals < -min_value,
      nonzero  = vals != 0
    )

    gr_keep <- base_gr[keep]
    if (length(gr_keep) == 0L) {
      # write empty 3-col BED if asked
      if (write_empty_files) {
        bed_file <- file.path(out_dir, paste0(.stem(strain), ".bed"))
        file.create(bed_file)
        if (isTRUE(promote_to_full_genes)) {
          bed_file_u <- file.path(out_dir, paste0(.stem(strain, is_universe = TRUE), ".bed"))
          file.create(bed_file_u)
        }
      }
      out_list_ranges[[strain]] <- data.frame()
      if (isTRUE(promote_to_full_genes)) out_list_genes[[strain]] <- data.frame()
      next
    }

    # --- WINDOW vs REGION output (3-col BEDs) ---
    if (mode == "window" && isTRUE(merge_windows)) {
      merged <- GenomicRanges::reduce(gr_keep, min.gapwidth = as.integer(max_gap_bp) + 1L)
      if (min_width_bp > 0L) {
        merged <- merged[IRanges::width(merged) >= as.integer(min_width_bp)]
      }
      gr_out <- merged
    } else {
      gr_out <- gr_keep
    }

    # Build 3-col BED df for ranges (write & assign)
    df_ranges <- as.data.frame(gr_out)[, c("seqnames","start","end")]
    if (isTRUE(zero_based)) df_ranges$start <- as.integer(df_ranges$start) - 1L
    df_ranges$start[df_ranges$start < 0L] <- 0L
    df_ranges$seqnames <- as.character(df_ranges$seqnames)
    df_ranges$start    <- as.integer(df_ranges$start)
    df_ranges$end      <- as.integer(df_ranges$end)

    stem_ranges <- .stem(strain)
    file_ranges <- file.path(out_dir, paste0(stem_ranges, ".bed"))
    utils::write.table(df_ranges, file_ranges, sep = "\t", quote = FALSE,
                       row.names = FALSE, col.names = FALSE)
    out_list_ranges[[strain]] <- df_ranges
    if (isTRUE(create_dataframes)) {
      assign(paste0(stem_ranges, "_BED"), df_ranges, envir = .GlobalEnv)
    }

    # --- Promote to full genes (restore: source_regions_df -> gene IDs -> subset universe_df) ---
    if (isTRUE(promote_to_full_genes)) {
      # recover keys for kept windows/regions and map to gene IDs via original region set
      kept_keys <- hm_key[keep]
      # pull gene IDs for those keys (drop NAs)
      kept_genes <- key2gene[kept_keys]
      kept_genes <- unique(as.character(kept_genes[!is.na(kept_genes)]))

      if (!length(kept_genes)) {
        # nothing to subset; write empty if requested
        if (write_empty_files) {
          bed_file_u <- file.path(out_dir, paste0(.stem(strain, is_universe = TRUE), ".bed"))
          file.create(bed_file_u)
        }
        out_list_genes[[strain]] <- data.frame()
        if (isTRUE(create_dataframes)) {
          assign(paste0(.stem(strain, is_universe = TRUE), "_BED"), data.frame(), envir = .GlobalEnv)
        }
      } else {
        if (!universe_gene_col %in% names(universe_df))
          stop("universe_gene_col not found in universe_df.")

        # exact subset by gene ID
        df_genes <- universe_df[universe_df[[universe_gene_col]] %in% kept_genes, , drop = FALSE]

        # Write genes bed (keep *universe* coords as stored; only adjust to 0-based if requested for file)
        stem_genes <- .stem(strain, is_universe = TRUE)
        file_genes <- file.path(out_dir, paste0(stem_genes, ".bed"))

        # For writing: if universe is 1-based but we want BED 0-based, temporarily adjust a copy
        dfw <- df_genes
        if (isTRUE(zero_based) && !isTRUE(universe_is_zero_based)) {
          # assume universe_df has V2 as start
          if ("V2" %in% names(dfw)) {
            dfw$V2 <- as.integer(dfw$V2) - 1L
            dfw$V2[dfw$V2 < 0L] <- 0L
          }
        }
        utils::write.table(dfw, file_genes, sep = "\t", quote = FALSE,
                           row.names = FALSE, col.names = FALSE)

        out_list_genes[[strain]] <- df_genes
        if (isTRUE(create_dataframes)) {
          assign(paste0(stem_genes, "_BED"), df_genes, envir = .GlobalEnv)
        }
      }
    }
  }

  invisible(list(ranges = out_list_ranges, genes = out_list_genes))
}

```

```{r, Run BED File Function}
###You'll want to feed Heatmap dfs into this function

# Example 1: vInput heatmap, enriched regions per strain (merge abutting; min merged width 1500 bp)
peaks_win <- heatmap_to_bed_peaks(
  hm_df         = H3K36me3_Heatmap_GenomeWide_vInput,
  out_dir       = "csaw_beds/H3K36me3_vInput",
  prefix        = "H3K36me3_vInput",
  mode          = "window",
  direction     = "positive",
  min_value     = 0,
  merge_windows = TRUE,
  max_gap_bp    = 1500,
  min_width_bp  = 1000,
  zero_based    = FALSE,
  write_empty_files = TRUE
)

# Example 2: vInput heatmap, enriched regions per strain across a pre-determined region set (i.e. all genes)
peaks <- heatmap_to_bed_peaks(
  hm_df         = H3K36me3_Heatmap_K27promTSS_vWT,
  out_dir       = "csaw_beds/H3K36me3_vWT",
  prefix        = "H3K36me3_lost_K27genes",
  mode          = "region",
  direction     = "negative",
  min_value     = 0.75,                         
  merge_windows = FALSE,                     # ignored in region mode anyway
  zero_based    = TRUE,
  file_norm_tag = NULL,                      # OR "vInput"/"vWT" if you want it appended here
  source_regions_df = regions$K27promTSS, # needs to match your original region df with coords + gene IDs
  source_key_cols   = c("V1","V2","V3"),
  source_gene_col   = "V10",      # may want to use V11, which has NCUs instead of names (change below)
  promote_to_full_genes  = TRUE,
  universe_df            = regions$K27genes, #IMPORTANT: The df you want to subset
  universe_gene_col      = "V10",
  universe_label         = "genes",
  universe_is_zero_based = FALSE,          
  create_dataframes      = TRUE
)


```

```{r, Processing Dataframes}
#Use these template commands for processing dataframes to create csvs, bed files, etc. for downstream analysis or use outisde of R. Note, these are not tied to any functions, just some useful lines of code to process the outputs of the analysis functions

#reassign gene names to data frame of interest using dplyr. This is useful if you are wanting to extract out a list of genes of interest (like genes that lose K27me3 in a mutant). 
library(dplyr)

H3K36me3_Results_K27promTSS_vWT <- H3K36me3_Results_K27promTSS_vWT %>%
  left_join(
    regions$K27promTSS %>% select(V1, V2, V3, V10), #you may have to change the column names 
    by = c("seqnames" = "V1", "start" = "V2", "end" = "V3")
  )

#subset your original bed file for genes/regions of interest. For example, here, I will subset my promoter-TSS bed to only include genes that lose H3K36me3 in cac-1 or cac-2

##isolate genes of interest
CAF1_K36_lost = subset(H3K36me3_Results_K27promTSS_vWT, H3K36me3_Results_K27promTSS_vWT$logFC_cac1 < -0.75 | H3K36me3_Results_K27promTSS_vWT$logFC_cac2 < -0.75)

##subset the bed
K36_lost_bed = subset(K27_genes, K27_genes$V10 %in% CAF1_K36_lost$V10)
K36_not_lost_bed = subset(K27_genes, ! K27_genes$V10 %in% K36_lost_bed$V10)

write.table(K36_lost_bed, file = "CAF-1_H3K36me3_lost_K27_genes.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(K36_not_lost_bed, file = "CAF-1_H3K36me3_not_lost_K27_genes.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

#Subset files from bed file function (later in script). Here, I am pulling out all genes that don't have H3K36 in ash-1, and that aren't in K27 regions
gr_wt   <- GRanges(H3K36me3_allgenes_vInput_WT_BED$seqnames,
                   IRanges(H3K36me3_allgenes_vInput_WT_BED$start + 1,
                           H3K36me3_allgenes_vInput_WT_BED$end))
gr_ash1 <- GRanges(H3K36me3_allgenes_vInput_ash1_BED$seqnames,
                   IRanges(H3K36me3_allgenes_vInput_ash1_BED$start + 1,
                           H3K36me3_allgenes_vInput_ash1_BED$end))

WT_not_in_ash1 <- H3K36me3_allgenes_vInput_WT_BED[countOverlaps(gr_wt, gr_ash1) == 0, ]

#ash-1 methylated genes
H3K36me3_no_ash1 = subset(H3K36me3_lost_genes_log2FC_1_ash1_genes_BED, H3K36me3_lost_genes_log2FC_1_ash1_genes_BED$V10 %in% regions$allgenes$V10 )

#ash-1 methylated, non-K27
H3K36me3_no_ash1_nonK27 = subset(H3K36me3_no_ash1, ! H3K36me3_no_ash1$V10 %in% K27_enriched$V10 )

#Not ash-1 methylated
H3K36me3_set2_meth <- subset(H3K36me3_enriched_genes_log2FC_0.5_WT_genes_BED, ! H3K36me3_enriched_genes_log2FC_0.5_WT_genes_BED$V10 %in% H3K36me3_no_ash1$V10 & ! H3K36me3_enriched_genes_log2FC_0.5_WT_genes_BED$V10 %in% K27_enriched$V10)

#write files
write.table(H3K36me3_no_ash1_nonK27, file = "ash1_meth_nonK27.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

write.table(H3K36me3_set2_meth, file = "set2_meth_only.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

#K27 enrichment
K27_enriched = subset(H3K27me3_promTSS_enriched_log2FC_2_WT_genes_BED, H3K27me3_promTSS_enriched_log2FC_2_WT_genes_BED$gene_id %in% H3K27me3_prom_enriched_log2FC_2_WT_genes_BED$gene_id)

H3K27me3_inCAF1 = subset(K27_enriched, ! K27_enriched$gene_id %in% H3K27me3_lost_genes_log2FC_2_cac1_genes_BED$gene_id | ! K27_enriched$gene_id %in% H3K27me3_lost_genes_log2FC_2_cac2_genes_BED$gene_id)

H3K27me3_noCAF1 = subset(K27_enriched, K27_enriched$gene_id %in% H3K27me3_lost_genes_log2FC_2_cac1_genes_BED$gene_id | K27_enriched$gene_id %in% H3K27me3_lost_genes_log2FC_2_cac2_genes_BED$gene_id)
 
write.table(H3K27me3_inCAF1, file = "H3K27me3_CAF1_retain.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(H3K27me3_noCAF1, file = "H3K27me3_CAF1_lost.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE) 

####i want to subset genes that lose K27 or K36 in cac-1 or cac-2
K27lost = subset(H3K27me3_CS_Results_K27promTSS_vWT, H3K27me3_CS_Results_K27promTSS_vWT$logFC_cac1 < -0.75 | H3K27me3_CS_Results_K27promTSS_vWT$logFC_cac2 < -0.75)
#K27lost = subset(K27lost, K27lost$FDR_cac1 < 0.05 | K27lost$FDR_cac2 < 0.05)
K27lost = subset(regions$K27genes, regions$K27genes$gene_id %in% K27lost$gene_id)

K36lost = subset(H3K36me3_Results_K27promTSS_vWT, H3K36me3_Results_K27promTSS_vWT$logFC_cac1 < -0.75 | H3K36me3_Results_K27promTSS_vWT$logFC_cac2 < -0.75)
#K36lost = subset(K36lost, K36lost$FDR_cac1 < 0.05 | K36lost$FDR_cac2 < 0.05)
K36lost = subset(regions$K27genes, regions$K27genes$gene_id %in% K36lost$gene_id)

retainK27 = subset(regions$K27genes, ! regions$K27genes$gene_id %in% K27lost$gene_id)
retainK36 = subset(regions$K27genes, ! regions$K27genes$gene_id %in% K36lost$gene_id)

write.table(K27lost, file = "CAF-1_K27lost.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(K36lost, file = "CAF-1_K36lost.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE) 

write.table(retainK27, file = "CAF-1_K27retain.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(retainK36, file = "CAF-1_K36retain.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE) 

#####
K27lost_only = subset(K27lost, ! K27lost$gene_id %in% K36lost$gene_id)
K27_K36retain = subset(regions$K27genes, ! regions$K27genes$gene_id %in% K36lost$gene_id & ! regions$K27genes$gene_id %in% K27lost$gene_id)

write.table(K27lost_only, file = "CAF1_K27_lost_only.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(K27_K36retain, file = "CAF1_K36_K27_retain.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

```