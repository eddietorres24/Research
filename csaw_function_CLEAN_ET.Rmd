---
title: "csaw_function_CLEAN_ET"
author: "Eddie Torres"
date: "2025-08-04"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)

# Set working environment

workingdir="C:/Users/eddie/Research/GitHub"

#set working directory to the correct location for working machine
knitr::opts_knit$set(root.dir = "workingdir")

library(dplyr)
  require(csaw)
  require(edgeR)
  library(GenomicRanges)
  library(Rsamtools)
  library(S4Vectors)
  library(SummarizedExperiment)


```

```{r, read in metadata & regions of interest}
#reading in metdata
meta <- read.csv("../csaw_samples_files/cac_csaw.csv")

#fix path (if necessary, should only be if you're in wrong directory)
meta <- meta %>%
  mutate(bamReads = paste0("../", bamReads))

#Build group factor from csaw metadata
grouping <- factor(paste(meta$Strain, meta$Antibody, sep = "."))

#Design matrix using this grouping for downstream comaprisons
design.mat <- model.matrix(~ 0 + grouping)
colnames(design.mat) <- levels(grouping)

###########remove mat locus               1856250. 1862401 36 - 37
matLocus <- GRanges("CM002236.1", IRanges(1856288, 1862459)) # mat

##set parameters for windowCounts
param <- readParam(discard = matLocus, pe="none", max.frag=1500, minq=20 )

#reading in regions of interest
regions <- list(K27genes_proms = read.table("../bed_files/K27_genes_prom_100pct_overlap.bed"), K27genes = read.table("../bed_files/K27_genes_stringent.bed"), K27proms = read.table("../bed_files/K27_promoters.bed"), K27promTSS = read.table("../bed_files/K27_prom_TSS.bed"), allgenes = read.table("../bed_files/all_genes_forR.bed")) 

###IMPORTANT: the tables you  read into your list should not have a header (i.e., the column names should be V1, V2, ... VX). If your columns have other names, the count function may not recognize it properly. even if the files you read in have headers, i believe you can adjust the way read.table reads it into a df object. check column names in the "regions" object before continuing

#with "list" you can read multiple beds into the function

#once you load in all the metadata and bed with regions, run the first function to count data and make a dge object

```

```{r, csaw count & dge function, echo = FALSE}
###KEY NOTE: leave this and the following functions *unedited*, this is the default function, all you need to do is edit the parameters in the block below and its one-click (blocks flanked by hashtags ###). I explain what each paramter does below, and what each consecutive function does in each block###

#This function will count in your data based on your loaded metadata and provided regions of interests. you will want to include any blacklisted regions (i.e. mat locus) with your param object.

csaw_count_and_fit <- function(
  metadata_df,
  region_list = NULL,           # data frame OR named list of data frames (BED-like)
  mode = c("window", "region"), # choose count mode
  window_size = 300,            # used only for window mode
  design_mat,                   # precomputed model matrix
  param,                        # readParam() object (your defaults will be copied)
  assign_to_global = TRUE,      # save named objects to global environment
  return_list = TRUE            # return everything in a nested list
) {
  require(csaw)
  require(edgeR)
  require(GenomicRanges)
  require(Rsamtools)
  require(S4Vectors)
  require(SummarizedExperiment)

  mode <- match.arg(mode)

  ## ---------------- sanity helpers ----------------
  df_to_granges <- function(df) {
    cols <- names(df)
    chr <- if ("V1" %in% cols) df$V1 else if ("chrom" %in% cols) df$chrom else stop("No chrom/V1 column in region data.frame")
    start <- if ("V2" %in% cols) df$V2 else if ("start" %in% cols) df$start else stop("No start/V2 column in region data.frame")
    end   <- if ("V3" %in% cols) df$V3 else if ("end"   %in% cols) df$end   else stop("No end/V3 column in region data.frame")
    strd  <- if ("V6" %in% cols) df$V6 else if ("strand" %in% cols) df$strand else "*"
    start <- as.integer(start); end <- as.integer(end)
    if (any(is.na(start) | is.na(end))) stop("Start/end contain NAs after coercion. Check region input.")
    GRanges(seqnames = chr, ranges = IRanges(start = start, end = end), strand = strd)
  }

  as_named_list <- function(x) {
    if (is.null(x)) return(NULL)
    if (is.list(x) && !is.data.frame(x)) {
      if (is.null(names(x)) || any(names(x) == "")) {
        stop("region_list must be a *named* list, e.g. list(K27genes_proms = df).")
      }
      return(x)
    } else if (is.data.frame(x)) {
      return(list(genome_set = x))
    } else {
      stop("region_list must be a data.frame or a named list of data.frames.")
    }
  }

  detect_paired <- function(bam, n = 5000L) {
    bf <- BamFile(bam, yieldSize = n)
    open(bf); on.exit(close(bf), add = TRUE)
    x <- scanBam(bf, param = ScanBamParam(what = "flag"))[[1]]$flag
    if (length(x) == 0) return(FALSE)
    # bit 0x1 => isPaired
    any(bitwAnd(x, 1L) != 0L)
  }

  # try to clone readParam() while overriding `pe=`
  set_pe <- function(param_in, pe_mode = c("none","both")) {
    pe_mode <- match.arg(pe_mode)
    # Best effort: copy main knobs if present; otherwise fall back to defaults from `param_in`
    # Extract what we can via show() parsing fallback is messy; instead we accept common fields explicitly:
    # If slot access works, use it; otherwise default.
    get_slot <- function(obj, nm, default = NULL) {
      if (nm %in% slotNames(obj)) slot(obj, nm) else default
    }
    rp <- readParam(
      pe      = pe_mode,
      max.frag = get_slot(param_in, "max.frag", 1500L),
      dedup   = get_slot(param_in, "dedup", FALSE),
      minq    = get_slot(param_in, "minq", 20L),
      forward = get_slot(param_in, "forward", NA),
      restrict = get_slot(param_in, "restrict", NULL)
    )
    rp
  }

  stopifnot(is.data.frame(metadata_df))
  needed <- c("Strain","Antibody","bamReads","Replicate")
  if (!all(needed %in% names(metadata_df))) {
    stop("metadata_df must contain columns: Strain, Antibody, Replicate, bamReads")
  }

  # grouping (used for design compatibility check)
  grouping <- factor(paste(metadata_df$Strain, metadata_df$Antibody, sep = "."))
  if (!all(levels(grouping) %in% colnames(design_mat))) {
    missing_cols <- setdiff(levels(grouping), colnames(design_mat))
    stop(paste0("design_mat is missing columns for these groups: ", paste(missing_cols, collapse = ", ")))
  }

  # pretty column labels (samples) used in DGE objects
  nice_labels <- paste(metadata_df$Strain, metadata_df$Antibody, paste0("R", metadata_df$Replicate), sep = ".")

  # normalize region_list input shape
  region_list <- as_named_list(region_list)

  # file existence
  bam_files <- metadata_df$bamReads
  exist <- file.exists(bam_files)
  if (!all(exist)) {
    stop("Missing BAM(s): ", paste(bam_files[!exist], collapse = ", "))
  }

  # warn about old index timestamps (harmless but noisy)
  if (interactive()) {
    bai_exists <- file.exists(paste0(bam_files, ".bai")) | file.exists(sub("\\.bam$", ".bai", bam_files))
    if (!all(bai_exists)) {
      warning("One or more BAM index (.bai) files are missing; samtools will auto-index or counts may be slow.")
    }
  }

  # detect PE/SE per BAM
  is_pe <- vapply(bam_files, detect_paired, logical(1))
  pe_bams <- bam_files[is_pe]
  se_bams <- bam_files[!is_pe]

  if (length(pe_bams) == 0L && length(se_bams) == 0L) stop("No BAMs detected.")
  message(sprintf("Detected %d PE and %d SE BAMs.", length(pe_bams), length(se_bams)))

  # build param variants
  param_pe <- set_pe(param, "both")
  param_se <- set_pe(param, "none")

  # container
  out <- list(genomewide = NULL, regions = list())

  # helper: ensure columns are in the original metadata order
  reorder_se_cols <- function(se_obj, order_bams) {
    cb <- colData(se_obj)
    if (!"bam.files" %in% colnames(cb)) {
      # older csaw versions: rownames of colData are file paths
      current <- rownames(cb)
    } else {
      current <- as.character(cb$bam.files)
    }
    idx <- match(order_bams, current)
    if (anyNA(idx)) {
      stop("Failed to match counted columns back to original BAM order.")
    }
    se_obj[, idx]
  }

  # helper: run windowCounts for a vector of BAMs (possibly length 0)
  run_window <- function(bams, rp) {
    if (length(bams) == 0L) return(NULL)
    windowCounts(bam.files = bams, spacing = window_size, width = window_size,
                 shift = 0, filter = 0, bin = TRUE, param = rp)
  }

  # helper: run regionCounts for a vector of BAMs
  run_region <- function(bams, rp, gr) {
    if (length(bams) == 0L) return(NULL)
    regionCounts(bam.files = bams, regions = gr, param = rp)
  }

  # helper: bind two SE objects after verifying rows match
  bind2 <- function(a, b) {
    if (is.null(a)) return(b)
    if (is.null(b)) return(a)
    if (!identical(rowRanges(a), rowRanges(b))) {
      stop("Row ranges do not match between SE and PE counting—this should not happen. Check genome/spacing/regions.")
    }
    cbind(a, b)
  }

  # helper: fast fail if any sample has zero total counts
  stop_if_zero_totals <- function(se_obj, context_label) {
    tot <- colSums(assay(se_obj))
    bad <- which(tot == 0)
    if (length(bad)) {
      cb <- colData(se_obj)
      labs <- if ("bam.files" %in% colnames(cb)) as.character(cb$bam.files) else rownames(cb)
      stop(sprintf("Zero total counts in %s for samples: %s\nThis yields non-finite offsets; fix inputs or region set and retry.",
                   context_label, paste(labs[bad], collapse = ", ")))
    }
    invisible(NULL)
  }

  ## ---------------- counting & modeling ----------------
  if (mode == "window") {
    message("Counting genome-wide windows (spacing/width = ", window_size, ") ...")

    data_pe <- run_window(pe_bams, param_pe)
    data_se <- run_window(se_bams, param_se)
    data_all <- bind2(data_se, data_pe)
    if (is.null(data_all)) stop("No windows counted (empty result).")

    # Put columns back to original metadata order
    data_all <- reorder_se_cols(data_all, bam_files)

    # fail fast on zero sums
    stop_if_zero_totals(data_all, "genome-wide windows")

    # DGE/disp/fit with sample labels and grouping
    dge_all  <- asDGEList(data_all, group = grouping)
    colnames(dge_all$counts) <- nice_labels
    rownames(dge_all$samples) <- nice_labels

    disp_all <- estimateDisp(dge_all, design_mat)
    fit_all  <- glmQLFit(disp_all, design_mat, robust = TRUE)

    if (assign_to_global) {
      assign("dge_genomewide",  dge_all,  envir = .GlobalEnv)
      assign("disp_genomewide", disp_all, envir = .GlobalEnv)
      assign("fit_genomewide",  fit_all,  envir = .GlobalEnv)
    }
    out$genomewide <- list(dge = dge_all, disp = disp_all, fit = fit_all, counts = data_all)

    # Optional: filtered genome-wide → region subsets
    if (!is.null(region_list)) {
      rr_all <- rowRanges(data_all)
      for (nm in names(region_list)) {
        message("Filtering genome-wide windows to region set: ", nm)
        gr <- df_to_granges(region_list[[nm]])
        keep <- overlapsAny(rr_all, gr, type = "within")
        filtered <- data_all[keep, ]

        stop_if_zero_totals(filtered, paste0("filtered windows (", nm, ")"))

        dge  <- asDGEList(filtered, group = grouping)
        colnames(dge$counts) <- nice_labels
        rownames(dge$samples) <- nice_labels
        disp <- estimateDisp(dge, design_mat)
        fit  <- glmQLFit(disp, design_mat, robust = TRUE)

        safe <- make.names(nm)
        if (assign_to_global) {
          assign(paste0("gr_",   safe), gr,   envir = .GlobalEnv)
          assign(paste0("dge_",  safe), dge,  envir = .GlobalEnv)
          assign(paste0("disp_", safe), disp, envir = .GlobalEnv)
          assign(paste0("fit_",  safe), fit,  envir = .GlobalEnv)
        }
        out$regions[[nm]] <- list(gr = gr, dge = dge, disp = disp, fit = fit, counts = filtered)
      }
    }

  } else { # mode == "region"
    if (is.null(region_list)) stop("In region mode, region_list (one or more BED data.frames) is required.")
    for (nm in names(region_list)) {
      message("Counting over regions: ", nm)
      gr <- df_to_granges(region_list[[nm]])

      counts_pe <- run_region(pe_bams, param_pe, gr)
      counts_se <- run_region(se_bams, param_se, gr)
      counts_all <- bind2(counts_se, counts_pe)
      if (is.null(counts_all)) stop("No region counts returned (empty result).")

      # Reorder to original BAM order
      counts_all <- reorder_se_cols(counts_all, bam_files)

      stop_if_zero_totals(counts_all, paste0("regions (", nm, ")"))

      dge  <- asDGEList(counts_all, group = grouping)
      colnames(dge$counts) <- nice_labels
      rownames(dge$samples) <- nice_labels
      disp <- estimateDisp(dge, design_mat)
      fit  <- glmQLFit(disp, design_mat, robust = TRUE)

      safe <- make.names(nm)
      if (assign_to_global) {
        assign(paste0("gr_",   safe), gr,   envir = .GlobalEnv)
        assign(paste0("dge_",  safe), dge,  envir = .GlobalEnv)
        assign(paste0("disp_", safe), disp, envir = .GlobalEnv)
        assign(paste0("fit_",  safe), fit,  envir = .GlobalEnv)
      }
      out$regions[[nm]] <- list(gr = gr, dge = dge, disp = disp, fit = fit, counts = counts_all)
    }
  }

  if (return_list) return(out) else invisible(NULL)
}


```

###########################################################################################
```{r, run count & fit function, echo = FALSE}

#This is where you change the parameters and run the function
count_results <- csaw_count_and_fit(
  metadata_df = meta,
  region_list = regions,
  mode = "region", #"region" or "window"
  window_size = 300,
  design_mat = design.mat,
  param = param
)

```
###########################################################################################

```{r, csaw QC function}
#This function can be used to run all relevant QC checks on the ChIP data you counted in the first function. you should choose "region" or "window based on what mode you used for the first function

# ---------- QC function (run after your counting/fitting) ----------
qc_csaw <- function(
  metadata_df,
  out_obj = NULL,                    # optional list returned by csaw_count_and_fit(); if NULL we autodiscover from .GlobalEnv
  mode = c("window","region"),       # whichever you actually ran
  out_dir = "qc_csaw",
  which_sets = c("both","genomewide","regions")  # what to QC
) {
  mode <- match.arg(mode)
  which_sets <- match.arg(which_sets)

  stopifnot(is.data.frame(metadata_df))
  if (!all(c("Strain","Antibody","bamReads") %in% names(metadata_df))) {
    stop("metadata_df must have Strain, Antibody, bamReads")
  }

  # --- deps ---
  require(edgeR)
  require(limma)     # <-- add this
  require(ggplot2)

  # --- helpers ---
  safe_dir <- function(d){ 
    if (!dir.exists(d)) dir.create(d, recursive = TRUE)
    normalizePath(d, mustWork = FALSE) 
  }
  png_wrap  <- function(file, expr, w=1800, h=1200, res=200){
    png(file, width=w, height=h, res=res)
    on.exit(dev.off(), add=TRUE)
    force(expr)
  }

  # Discover objects from GlobalEnv if no list provided
  discover_from_global <- function() {
    nm <- ls(.GlobalEnv)
    res <- list()
    if (which_sets %in% c("both","genomewide")) {
      if (all(c("dge_genomewide","disp_genomewide","fit_genomewide") %in% nm)) {
        res$genomewide <- list(
          dge  = get("dge_genomewide",  envir = .GlobalEnv),
          disp = get("disp_genomewide", envir = .GlobalEnv),
          fit  = get("fit_genomewide",  envir = .GlobalEnv)
        )
      }
    }
    if (which_sets %in% c("both","regions")) {
      region_names <- unique(gsub("^(dge|disp|fit)_", "", nm[grepl("^(dge|disp|fit)_", nm)]))
      res$regions <- list()
      for (rn in region_names) {
        if (all(c(paste0("dge_",rn), paste0("disp_",rn), paste0("fit_",rn)) %in% nm)) {
          res$regions[[rn]] <- list(
            dge  = get(paste0("dge_", rn),  envir = .GlobalEnv),
            disp = get(paste0("disp_", rn), envir = .GlobalEnv),
            fit  = get(paste0("fit_", rn),  envir = .GlobalEnv)
          )
        }
      }
    }
    res
  }

  # get objects
  results <- if (!is.null(out_obj)) out_obj else discover_from_global()
  out_dir <- safe_dir(out_dir)

  qc_one <- function(dge, disp, fit, label) {
    subdir <- safe_dir(file.path(out_dir, label))

    # Library size barplot
    libfile <- file.path(subdir, "libsize_barplot.png")
    png_wrap(libfile, {
      barplot(dge$samples$lib.size/1e6, names = colnames(dge), las = 2,
              ylab = "Library size (millions)", main = paste("Library sizes -", label))
    })

    # MDS plot (force limma’s method for DGEList)
    mdsfile <- file.path(subdir, "MDS_plot.png")
    png_wrap(mdsfile, {
      limma::plotMDS(dge, main = paste("MDS plot -", label))  # <-- changed
      # if you *still* get grief from masking, this is a belt-and-suspenders option:
      # limma::plotMDS(edgeR::cpm(dge, log=TRUE, prior.count=2), main = paste("MDS plot -", label))
    })

    # BCV plot
    bcvfile <- file.path(subdir, "BCV_plot.png")
    png_wrap(bcvfile, {
      edgeR::plotBCV(disp, main = paste("BCV plot -", label))
    })

    # Mean–variance plot (custom, log2 CPM)
    mvfile <- file.path(subdir, "meanvar_plot.png")
    png_wrap(mvfile, {
      cpm_mat <- edgeR::cpm(dge, log = TRUE, prior.count = 2)
      means <- rowMeans(cpm_mat)
      vars  <- apply(cpm_mat, 1, var)
      plot(means, vars, pch = 16, cex = 0.4,
           xlab = "Mean log2 CPM", ylab = "Variance (log2 CPM)",
           main = paste("Mean–Variance (log2 CPM) -", label))
      lines(lowess(means, vars), lwd = 2, col = "red")
    })

    # QL dispersion plot
    qldfile <- file.path(subdir, "QL_dispersion_plot.png")
    png_wrap(qldfile, {
      edgeR::plotQLDisp(fit, main = paste("QL dispersion -", label))
    })
  }

  # Run QC
  if (which_sets %in% c("both","genomewide") && !is.null(results$genomewide)) {
    with(results$genomewide, qc_one(dge, disp, fit, "genomewide"))
  }
  if (which_sets %in% c("both","regions") && !is.null(results$regions)) {
    for (nm in names(results$regions)) {
      with(results$regions[[nm]], qc_one(dge, disp, fit, nm))
    }
  }

  message("QC complete. Plots saved to: ", out_dir)
}

```

###########################################################################################
```{r, Run QC function}

#This is where you change the paramters and run the function
qc_csaw(
  metadata_df = meta,
  out_obj = NULL, # autodiscover from global env, Use "count_results" if variables not in global
  mode = "region", # "region" or "window" depending on choice in count fxn.
  out_dir = "QCTEST", #output directory, name whatever you want
  which_sets = "regions" # "genomewide", "regions", or "both"
)

```
###########################################################################################

```{r, csaw analysis fucntion}
#This function is going to now analyze the data that you have read in, and calculate the signal over background, normalized to input or WT (or another strain for interest). It will make a couple dataframes for each normalization, for each modifcation analyzed: one with all results (log2FC, FDR, etc.), and one with only log2FC values for heatmap generation. There is also options built in to write analyzed data & statistics to a csv, as well as make an igv track for browser visualization.

# - WINDOW mode:
#     * vInput: keep windows where >=1 strain is (FDR<=cut &/or P<=cut) AND logFC>0,
#               then zero per-strain logFC where that strain FAILS (or logFC<=0)
#     * vRef  : keep windows where >=1 strain is (FDR<=cut &/or P<=cut) (+ or -),
#               then zero per-strain logFC where that strain FAILS.
# - REGION mode:
#     * No masking by default; if mask_region=TRUE, zero per-strain logFC by FDR/P-val
# ---- Run csaw contrasts across ALL mods & ALL region sets ----

csaw_analysis <- function(
  metadata_df,
  design_mat,
  mode = c("window","region"),
  out_obj = NULL,
  reference_strain = "WT",
  fdr_cutoff = 0.05,
  pvalue_cutoff = NULL,
  mask_region = FALSE,
  write_csv_results = FALSE,
  write_csv_heatmap = FALSE,
  write_igv = FALSE,
  out_dir = "csaw_results",
  merge_tol = 300
) {
  require(edgeR)
  require(limma)
  require(csaw)
  require(GenomicRanges)
  require(S4Vectors)

  mode <- match.arg(mode)
  if (is.null(out_obj)) stop("out_obj is required (use the list returned by csaw_count_and_fit).")
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # ---------- helpers ----------
  order_cols_wt_first <- function(nms, wt = "WT") {
    wt_hit <- grep(paste0("^logFC_", wt, "$"), nms, value = TRUE)
    rest   <- setdiff(nms, wt_hit)
    c(wt_hit, rest)
  }

  # IGV writer: coords from results (ordered to match heatmap rows), values from heatmap
  .write_igv_from_heatmap <- function(res_df, hm_df, file_path) {
    if (!nrow(hm_df)) {
      warning("Heatmap df has 0 rows; skipping IGV: ", basename(file_path))
      return(invisible(NULL))
    }
    res_key <- paste(res_df$seqnames, res_df$start, res_df$end, sep = ".")
    idx <- match(rownames(hm_df), res_key)
    miss <- which(is.na(idx))
    if (length(miss)) {
      warning("Some heatmap rows not found in results; dropping ", length(miss), " rows for IGV.")
      keep <- !is.na(idx)
      hm_df <- hm_df[keep, , drop = FALSE]
      idx <- idx[keep]
      if (!length(idx)) {
        warning("No overlap between heatmap and results; skipping IGV.")
        return(invisible(NULL))
      }
    }
    res_sel <- res_df[idx, c("seqnames","start","end","name"), drop = FALSE]
    out <- cbind(res_sel, hm_df)  # values from heatmap (masked/filtered)
    write.table(out, file_path, sep = "\t", quote = FALSE, row.names = FALSE)
  }

  # store vInput row keys and masked vInput heatmaps per (mod, region_tag)
  keep_coords_env <- new.env(parent = emptyenv())
  vin_heatmap_env <- new.env(parent = emptyenv())

  run_norm <- function(mod, fit, counts, region_tag, norm_type, gr_for_region = NULL) {
    res_list <- list()
    strains_all <- unique(metadata_df$Strain)
    strains <- if (norm_type == "input") strains_all else setdiff(strains_all, reference_strain)

    for (st in strains) {
      chip_col <- paste0(st, ".", mod)
      if (norm_type == "input") {
        st_input_col <- paste0(st, ".input")
        if (!(chip_col %in% colnames(design_mat)) || !(st_input_col %in% colnames(design_mat))) {
          message("    Skipping ", st, " (missing ", chip_col, " or ", st_input_col, ")")
          next
        }
        constr <- sprintf("`%s` - `%s`", chip_col, st_input_col)
      } else {
        st_input_col  <- paste0(st,               ".input")
        ref_chip_col  <- paste0(reference_strain, ".", mod)
        ref_input_col <- paste0(reference_strain, ".input")
        needed <- c(chip_col, st_input_col, ref_chip_col, ref_input_col)
        if (!all(needed %in% colnames(design_mat))) {
          missing <- paste(setdiff(needed, colnames(design_mat)), collapse = ", ")
          message("    Skipping ", st, " (missing: ", missing, ")")
          next
        }
        # still compute the proper contrast for the RESULTS table
        constr <- sprintf("`%s` - `%s` - (`%s` - `%s`)", chip_col, st_input_col, ref_chip_col, ref_input_col)
      }

      contrast <- limma::makeContrasts(contrasts = constr, levels = design_mat)
      res <- edgeR::glmQLFTest(fit, contrast = contrast)

      if (mode == "window") {
        merged <- mergeResults(counts, res$table, tol = merge_tol, merge.args = list(max.width = merge_tol))
        gr <- merged$regions
        mcols(gr) <- S4Vectors::DataFrame(merged$combined)
      } else {
        gr <- if (!is.null(gr_for_region)) gr_for_region else rowRanges(counts)
        m <- S4Vectors::mcols(gr)
        m$logFC  <- res$table$logFC
        m$PValue <- res$table$PValue
        m$FDR    <- if ("FDR" %in% colnames(res$table)) res$table$FDR else p.adjust(res$table$PValue, method = "BH")
        S4Vectors::mcols(gr) <- m
      }
      res_list[[st]] <- gr
    }

    if (length(res_list) == 0) return(NULL)

    base <- res_list[[1]]
    base_key_coords <- paste0(as.character(seqnames(base)), ".", start(base), ".", end(base))

    # RESULTS (never filtered/masked)
    final_df <- data.frame(
      seqnames = as.character(GenomicRanges::seqnames(base)),
      start    = GenomicRanges::start(base),
      end      = GenomicRanges::end(base),
      name     = rep(".", length(base)),
      strand   = as.character(GenomicRanges::strand(base)),
      stringsAsFactors = FALSE
    )
    for (st in names(res_list)) {
      gr <- res_list[[st]]
      mnames <- colnames(S4Vectors::mcols(gr))
      lfc_col <- if ("rep.logFC" %in% mnames) "rep.logFC" else
                 if ("logFC" %in% mnames) "logFC" else
                 stop("Neither rep.logFC nor logFC found for ", st, " (", mod, ")")
      final_df[[paste0("logFC_", st)]]  <- S4Vectors::mcols(gr)[[lfc_col]]
      final_df[[paste0("PValue_", st)]] <- S4Vectors::mcols(gr)[["PValue"]]
      final_df[[paste0("FDR_", st)]]    <- if ("FDR" %in% mnames) S4Vectors::mcols(gr)[["FDR"]] else
        p.adjust(S4Vectors::mcols(gr)[["PValue"]], method = "BH")
    }

    # HEATMAP (masked/filtered)
    logfc_cols <- grep("^logFC_", colnames(final_df), value = TRUE)
    logfc_cols <- order_cols_wt_first(logfc_cols, wt = reference_strain)
    heatmap_df <- final_df[, logfc_cols, drop = FALSE]
    rownames(heatmap_df) <- base_key_coords

    if (mode == "window") {
      if (norm_type == "input") {
        # per-strain masking & keep rows with any positive/sig
        for (st in sub("^logFC_", "", logfc_cols)) {
          lcol <- paste0("logFC_",  st)
          fcol <- paste0("FDR_",    st)
          pcol <- paste0("PValue_", st)
          mask <- (heatmap_df[[lcol]] <= 0)
          if (!is.null(fdr_cutoff)    && fcol %in% colnames(final_df))  mask <- mask | (final_df[[fcol]] > fdr_cutoff)
          if (!is.null(pvalue_cutoff) && pcol %in% colnames(final_df))  mask <- mask | (final_df[[pcol]] > pvalue_cutoff)
          heatmap_df[[lcol]][mask] <- 0
        }
        keep_any <- rowSums(heatmap_df > 0, na.rm = TRUE) > 0
        heatmap_df <- heatmap_df[keep_any, , drop = FALSE]

        key <- paste(mod, region_tag, sep = "::")
        keep_coords_env[[key]] <- rownames(heatmap_df)
        vin_heatmap_env[[key]] <- heatmap_df  # <-- store masked vInput for vWT derivation

      } else {
        # vWT derived from vInput: (strain - WT) row-wise using masked vInput values
        key <- paste(mod, region_tag, sep = "::")
        vin <- vin_heatmap_env[[key]]

        if (is.null(vin)) {
          warning("No stored vInput heatmap for ", key, "; falling back to contrast-based masking.")
          # fallback (old behavior): mask by FDR/P, restrict rows if we have coords
          kept_coords <- keep_coords_env[[key]]
          keep_rows <- if (is.null(kept_coords)) rep(TRUE, nrow(heatmap_df)) else (rownames(heatmap_df) %in% kept_coords)
          for (st in sub("^logFC_", "", logfc_cols)) {
            lcol <- paste0("logFC_",  st)
            fcol <- paste0("FDR_",    st)
            pcol <- paste0("PValue_", st)
            mask <- rep(FALSE, nrow(final_df))
            if (!is.null(fdr_cutoff)    && fcol %in% colnames(final_df))  mask <- mask | (final_df[[fcol]] > fdr_cutoff)
            if (!is.null(pvalue_cutoff) && pcol %in% colnames(final_df))  mask <- mask | (final_df[[pcol]] > pvalue_cutoff)
            heatmap_df[[lcol]][mask] <- 0
          }
          heatmap_df <- heatmap_df[keep_rows, , drop = FALSE]
        } else {
          # ensure WT column present
          wt_col <- paste0("logFC_", reference_strain)
          if (!(wt_col %in% colnames(vin))) {
            warning("WT column (", wt_col, ") not found in vInput heatmap for ", key, "; cannot compute vWT from vInput.")
            kept_coords <- keep_coords_env[[key]]
            keep_rows <- if (is.null(kept_coords)) rep(TRUE, nrow(heatmap_df)) else (rownames(heatmap_df) %in% kept_coords)
            heatmap_df <- heatmap_df[keep_rows, , drop = FALSE]
          } else {
            # make sure same row set & order as vInput
            heatmap_df <- vin
            # subtract WT row-wise, drop WT column
            non_wt_cols <- setdiff(colnames(heatmap_df), wt_col)
            if (length(non_wt_cols)) {
              heatmap_df <- sweep(heatmap_df[, non_wt_cols, drop = FALSE], 1, vin[[wt_col]], FUN = "-")
            } else {
              heatmap_df <- heatmap_df[, 0, drop = FALSE]
            }
          }
        }
      }

    } else {
      # REGION MODE: unchanged behavior; optional masking only
      if (isTRUE(mask_region)) {
        for (st in sub("^logFC_", "", logfc_cols)) {
          lcol <- paste0("logFC_",  st)
          fcol <- paste0("FDR_",    st)
          pcol <- paste0("PValue_", st)
          mask <- rep(FALSE, nrow(final_df))
          if (!is.null(fdr_cutoff)    && fcol %in% colnames(final_df))  mask <- mask | (final_df[[fcol]] > fdr_cutoff)
          if (!is.null(pvalue_cutoff) && pcol %in% colnames(final_df))  mask <- mask | (final_df[[pcol]] > pvalue_cutoff)
          heatmap_df[[lcol]][mask] <- 0
        }
      }
    }

    list(results = final_df, heatmap = heatmap_df)
  }
  # ---------- end helpers ----------

  all_mods <- setdiff(unique(metadata_df$Antibody), "input")

  if (mode == "region") {
    if (is.null(out_obj$regions) || !length(out_obj$regions)) stop("No region sets found in out_obj$regions.")
    for (nm in names(out_obj$regions)) {
      rg <- out_obj$regions[[nm]]
      fit    <- rg$fit
      counts <- rg$counts
      gr_in  <- if (!is.null(rg$gr)) rg$gr else rowRanges(counts)

      message("=== Region set: ", nm, " ===")
      for (mod in all_mods) {
        if (identical(mod, "input")) next

        # vInput
        res_vin <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "input", gr_for_region = gr_in)
        if (!is.null(res_vin)) {
          res_df <- res_vin$results
          hm_df  <- res_vin$heatmap
          res_name <- paste0(mod, "_Results_", nm, "_vInput")
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_vInput")
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_vInput.igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("  Modification: ", mod, "\n    -> Saved: ", res_name, " (and ", hm_name, ")")
        }

        # vWT (derived from vInput if available)
        res_vref <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "ref", gr_for_region = gr_in)
        if (!is.null(res_vref)) {
          res_df <- res_vref$results
          hm_df  <- res_vref$heatmap
          norm_tag <- paste0("v", reference_strain)
          res_name <- paste0(mod, "_Results_", nm, "_", norm_tag)
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_", norm_tag)
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_", norm_tag, ".igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("    -> Saved: ", res_name, " (and ", hm_name, ")")
        }
      }
    }
  } else {
    # WINDOW MODE
    if (!is.null(out_obj$genomewide)) {
      gw <- out_obj$genomewide
      fit    <- gw$fit
      counts <- gw$counts
      nm <- "GenomeWide"
      message("=== Window mode: ", nm, " ===")
      for (mod in all_mods) {
        if (identical(mod, "input")) next

        # vInput
        res_vin <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "input", gr_for_region = NULL)
        if (!is.null(res_vin)) {
          res_df <- res_vin$results
          hm_df  <- res_vin$heatmap
          res_name <- paste0(mod, "_Results_", nm, "_vInput")
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_vInput")
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_vInput.igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("  Modification: ", mod, "\n    -> Saved: ", res_name, " (and ", hm_name, ")")
        }

        # vWT (derived from vInput)
        res_vref <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "ref", gr_for_region = NULL)
        if (!is.null(res_vref)) {
          res_df <- res_vref$results
          hm_df  <- res_vref$heatmap
          norm_tag <- paste0("v", reference_strain)
          res_name <- paste0(mod, "_Results_", nm, "_", norm_tag)
          hm_name  <- paste0(mod, "_Heatmap_", nm, "_", norm_tag)
          assign(res_name, res_df, envir = .GlobalEnv)
          assign(hm_name,  hm_df,  envir = .GlobalEnv)
          if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
          if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
          if (write_igv) {
            igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_", norm_tag, ".igv"))
            .write_igv_from_heatmap(res_df, hm_df, igv_file)
          }
          message("    -> Saved: ", res_name, " (and ", hm_name, ")")
        }
      }
    }

    # genomewide filtered to regions (if present)
    if (!is.null(out_obj$regions) && length(out_obj$regions)) {
      for (nm in names(out_obj$regions)) {
        rg <- out_obj$regions[[nm]]
        fit    <- rg$fit
        counts <- rg$counts
        message("=== Window mode (filtered to regions): ", nm, " ===")
        for (mod in all_mods) {
          if (identical(mod, "input")) next

          # vInput
          res_vin <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "input", gr_for_region = NULL)
          if (!is.null(res_vin)) {
            res_df <- res_vin$results
            hm_df  <- res_vin$heatmap
            res_name <- paste0(mod, "_Results_", nm, "_vInput")
            hm_name  <- paste0(mod, "_Heatmap_", nm, "_vInput")
            assign(res_name, res_df, envir = .GlobalEnv)
            assign(hm_name,  hm_df,  envir = .GlobalEnv)
            if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
            if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
            if (write_igv) {
              igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_vInput.igv"))
              .write_igv_from_heatmap(res_df, hm_df, igv_file)
            }
            message("  Modification: ", mod, "\n    -> Saved: ", res_name, " (and ", hm_name, ")")
          }

          # vWT (derived from vInput)
          res_vref <- run_norm(mod, fit, counts, region_tag = nm, norm_type = "ref", gr_for_region = NULL)
          if (!is.null(res_vref)) {
            res_df <- res_vref$results
            hm_df  <- res_vref$heatmap
            norm_tag <- paste0("v", reference_strain)
            res_name <- paste0(mod, "_Results_", nm, "_", norm_tag)
            hm_name  <- paste0(mod, "_Heatmap_", nm, "_", norm_tag)
            assign(res_name, res_df, envir = .GlobalEnv)
            assign(hm_name,  hm_df,  envir = .GlobalEnv)
            if (write_csv_results) write.csv(res_df, file.path(out_dir, paste0(res_name, ".csv")), row.names = FALSE)
            if (write_csv_heatmap) write.csv(hm_df,  file.path(out_dir, paste0(hm_name,  ".csv")), row.names = TRUE)
            if (write_igv) {
              igv_file <- file.path(out_dir, paste0(mod, "_logFC_", nm, "_", norm_tag, ".igv"))
              .write_igv_from_heatmap(res_df, hm_df, igv_file)
            }
            message("    -> Saved: ", res_name, " (and ", hm_name, ")")
          }
        }
      }
    }
  }
}

```

###########################################################################################
```{r, run analysis function}

csaw_analysis(
  metadata_df = meta,
  design_mat  = design.mat,
  mode        = "region",             # "window" or "region"
  out_obj     = count_results,        # <- REQUIRED so we have counts for merging/coords
  reference_strain = "WT",
  fdr_cutoff  = 0.05,
  pvalue_cutoff = 0.05, 
  write_csv_results = TRUE,
  write_csv_heatmap = TRUE,
  write_igv   = TRUE,
  mask_region = TRUE,
  out_dir     = "CAF-1_Full_genome_Analysis", #output dir, name whatever you want
  merge_tol   = 300                   # only affects genomewide window mode
)

```
###########################################################################################

```{r, Heatmap Function}
#This function will be used to generate desired heatmaps using the generated dfs from the analysis function

# --- Heatmap helper for csaw *_Heatmap_* data frames ---
suppressPackageStartupMessages({
  library(ComplexHeatmap)
  library(circlize)
  library(dplyr)
  library(stringr)
  library(grid)
})

`%||%` <- function(a, b) if (!is.null(a)) a else b

make_csaw_heatmap_advanced <- function(
  df,                                  # data.frame with columns like logFC_*
  debug_logic = FALSE,
  debug_bucket = NULL,
  select_cols = NULL,                  # NULL = all; integer indices or strain names (e.g., c("WT","cac1"))
  present_threshold = NULL,            # NULL = none; numeric -> values < threshold set to 0 (affects plotting & "presence")
  clip_negatives_to_zero = FALSE,      # after thresholding: set negatives to 0
  global_filter = list(type = "any_ge", cols = "all", value = 0),  # drop rows failing this rule post-threshold
                                      # types: "any_ge","any_gt","all_ge","all_gt"
  use_buckets = FALSE,                 # TRUE = rule-based clusters (mutually exclusive, in order)
  buckets = NULL,                      # named list of rules, e.g. list(no_caf=list(present="WT", absent_all=c("cac1","cac2","cac3")))
                                      # rule keys: present, absent, present_all, present_any, absent_all, absent_any
  bucket_order_by = NULL,              # named list: for each bucket name, a strain or vector => rowMeans
  global_order_by = NULL,              # when buckets=FALSE: strain name or vector for rowMeans; NULL = no ordering
  cap_percentile = 0.995,              # winsorize upper tail to this percentile over selected columns; NULL = disable
  color_limits = NULL,                 # c(min,max); supports NA endpoints, e.g. c(0, NA) or c(NA, 2); NULL = auto from data
  colors = NULL,                       # NULL = auto; else vector or function for circlize::colorRamp2
  zero_white_band = NULL,
  show_row_names = FALSE,
  show_col_names = TRUE,
  cluster_rows = FALSE,                # ignored when use_buckets=TRUE (ordering determines row order)
  cluster_cols = FALSE,
  row_distance = "euclidean",
  row_linkage  = "complete",
  col_distance = "euclidean",
  col_linkage  = "complete",
  row_order = NULL,                    # enforce a predetermined rownames order (overrides buckets/ordering)
  out_dir = "csaw_heatmaps",
  out_stem = "csaw_heatmap",
  formats = c("pdf","png"),
  width_in = 6.5,                      # figure width (inches)
  base_height_in = 1.5,                # base height added regardless of rows
  per_row_height_in = 0.006,           # added height per row (inches)
  dpi = 300,
  return_objects = TRUE                # returns list(matrix, row_order, bucket_labels, heatmap)
) {
  stopifnot(is.data.frame(df))

  # keep only logFC_* columns
  lfccols <- grep("^logFC_", names(df), value = TRUE)
  if (length(lfccols) == 0) stop("No columns named like 'logFC_*' found.")
  M <- as.matrix(df[, lfccols, drop = FALSE])
  rownames(M) <- if (!is.null(rownames(df))) rownames(df) else paste0("row", seq_len(nrow(df)))

  # column selection
  strains_all <- sub("^logFC_", "", colnames(M))
  if (is.null(select_cols)) {
    keep_idx <- seq_along(strains_all)
  } else if (is.numeric(select_cols)) {
    keep_idx <- select_cols
  } else {
    want <- sub("^logFC_", "", select_cols)
    keep_idx <- match(want, strains_all)
    if (anyNA(keep_idx)) stop("Some selected strain names not found: ", paste(want[is.na(keep_idx)], collapse = ", "))
  }
  M <- M[, keep_idx, drop = FALSE]
  strains <- sub("^logFC_", "", colnames(M))

  # threshold: values below threshold -> 0 (also defines "presence")
  if (!is.null(present_threshold)) {
    M[M < present_threshold] <- 0
  }
  # optional: clip negatives to zero
  if (clip_negatives_to_zero) {
    M[M < 0] <- 0
  }

  # global row filter
  if (!is.null(global_filter)) {
    rule <- global_filter
    cols_sel <- if (is.null(rule$cols) || identical(rule$cols, "all")) {
      seq_len(ncol(M))
    } else {
      if (is.numeric(rule$cols)) rule$cols else match(rule$cols, strains)
    }
    if (anyNA(cols_sel)) stop("global_filter$cols contains unknown columns.")
    subM <- M[, cols_sel, drop = FALSE]
    val  <- as.numeric(rule$value %||% 0)
    keep <- switch(rule$type,
                   any_ge = rowSums(subM >= val, na.rm = TRUE) > 0,
                   any_gt = rowSums(subM >  val, na.rm = TRUE) > 0,
                   all_ge = rowSums(subM >= val, na.rm = TRUE) == ncol(subM),
                   all_gt = rowSums(subM >  val, na.rm = TRUE) == ncol(subM),
                   stop("Unknown global_filter$type: ", rule$type))
    M <- M[keep, , drop = FALSE]
  }
  if (nrow(M) == 0) stop("No rows left after filtering.")

  # winsorize upper cap
  if (!is.null(cap_percentile)) {
    cap <- as.numeric(stats::quantile(M, probs = cap_percentile, na.rm = TRUE))
    M[M > cap] <- cap
  }

  # presence/absence matrices for bucket rules (after threshold/clip)
  present_mat <- M > 0
  absent_mat  <- M == 0     # exact-zero definition for "absent_*" rules

  .debug <- list()

  # helper: map strain names → indices
  .col_idx <- function(cols) {
    if (is.null(cols) || length(cols) == 0) integer(0)
    if (is.numeric(cols)) return(cols)
    idx <- match(cols, strains)
    if (anyNA(idx)) stop("Unknown strains in rule: ", paste(cols[is.na(idx)], collapse = ", "))
    idx
  }

  # bucket assignment (exclusive, sequential)
  bucket_for_row <- rep(NA_character_, nrow(M))
  bucket_levels  <- character(0)

  if (isTRUE(use_buckets)) {
    if (is.null(buckets) || length(buckets) == 0) stop("use_buckets=TRUE but 'buckets' is empty.")
    for (bk in names(buckets)) {
      rule <- buckets[[bk]]
      pr  <- .col_idx(rule$present)
      ab  <- .col_idx(rule$absent)
      pra <- .col_idx(rule$present_all)
      pry <- .col_idx(rule$present_any)
      aba <- .col_idx(rule$absent_all)
      aby <- .col_idx(rule$absent_any)

      # Optional debug (pre-order)
      if (isTRUE(debug_logic) && (!is.null(debug_bucket) && identical(bk, debug_bucket))) {
        .debug$strains   <- strains
        .debug$rule_cols <- list(
          present      = pr,
          absent       = ab,
          present_all  = pra,
          present_any  = pry,
          absent_all   = aba,
          absent_any   = aby
        )
        .debug$clauses <- list(
          present_all  = if (length(pra)) rowSums(present_mat[, pra, drop = FALSE], na.rm = TRUE) == length(pra) else rep(TRUE, nrow(M)),
          present_any  = if (length(pry)) rowSums(present_mat[, pry, drop = FALSE], na.rm = TRUE) >= 1           else rep(TRUE, nrow(M)),
          absent_all   = if (length(aba)) rowSums(absent_mat[,  aba, drop = FALSE], na.rm = TRUE) == length(aba) else rep(TRUE, nrow(M)),
          absent_any   = if (length(aby)) rowSums(absent_mat[,  aby, drop = FALSE], na.rm = TRUE) >= 1           else rep(TRUE, nrow(M)),
          present_list = if (length(pr))  rowSums(present_mat[, pr,  drop = FALSE], na.rm = TRUE) == length(pr)  else rep(TRUE, nrow(M)),
          absent_list  = if (length(ab))  rowSums(absent_mat[,  ab,  drop = FALSE], na.rm = TRUE) == length(ab)  else rep(TRUE, nrow(M))
        )
      }

      # ---- FIX: combine ONLY the rule keys actually provided ----
      conds <- list()
      if (!is.null(rule$present)      && length(pr))  conds$present_list <- rowSums(present_mat[, pr,  drop = FALSE], na.rm = TRUE) == length(pr)
      if (!is.null(rule$absent)       && length(ab))  conds$absent_list  <- rowSums(absent_mat[,  ab,  drop = FALSE], na.rm = TRUE) == length(ab)
      if (!is.null(rule$present_all)  && length(pra)) conds$present_all  <- rowSums(present_mat[, pra, drop = FALSE], na.rm = TRUE) == length(pra)
      if (!is.null(rule$present_any)  && length(pry)) conds$present_any  <- rowSums(present_mat[, pry, drop = FALSE], na.rm = TRUE) >= 1
      if (!is.null(rule$absent_all)   && length(aba)) conds$absent_all   <- rowSums(absent_mat[,  aba, drop = FALSE], na.rm = TRUE) == length(aba)
      if (!is.null(rule$absent_any)   && length(aby)) conds$absent_any   <- rowSums(absent_mat[,  aby, drop = FALSE], na.rm = TRUE) >= 1

      ok <- if (length(conds)) Reduce("&", conds) else rep(TRUE, nrow(M))
      # -----------------------------------------------------------

      if (isTRUE(debug_logic) && (!is.null(debug_bucket) && identical(bk, debug_bucket))) {
        .debug$conds_names <- names(conds)
        .debug$ok <- ok
      }

      assignable <- which(ok & is.na(bucket_for_row))
      if (length(assignable)) bucket_for_row[assignable] <- bk
      bucket_levels <- c(bucket_levels, bk)
    }
    bucket_for_row[is.na(bucket_for_row)] <- "unassigned"
    bucket_levels <- unique(c(bucket_levels, "unassigned"))
  } else {
    bucket_for_row[] <- "all"
    bucket_levels <- "all"
  }

  # row ordering
  ord_rows <- integer(0)
  bucket_lab <- character(0)

  if (!is.null(row_order)) {
    present_rows <- rownames(M)
    rr <- intersect(row_order, present_rows)
    if (!length(rr)) stop("Provided row_order has no overlap with data.")
    M <- M[rr, , drop = FALSE]
    bucket_for_row <- bucket_for_row[match(rr, present_rows)]
    ord_rows <- seq_len(nrow(M))
    bucket_lab <- bucket_for_row
  } else if (isTRUE(use_buckets)) {
    for (bk in bucket_levels) {
      idx <- which(bucket_for_row == bk)
      if (!length(idx)) next
      sub <- M[idx, , drop = FALSE]
      sorter <- bucket_order_by[[bk]] %||% NULL
      if (is.null(sorter)) {
        # default: order by means of "present" columns in this bucket, else global rowMeans
        rule <- buckets[[bk]]
        pres_cols <- .col_idx(c(rule$present, rule$present_all, rule$present_any))
        score <- if (length(pres_cols) == 0) rowMeans(sub, na.rm = TRUE)
                 else rowMeans(sub[, unique(pres_cols), drop = FALSE], na.rm = TRUE)
      } else {
        sidx <- .col_idx(sorter)
        score <- if (length(sidx) == 1) sub[, sidx] else rowMeans(sub[, sidx, drop = FALSE], na.rm = TRUE)
      }
      o <- order(score, decreasing = TRUE, na.last = TRUE)
      ord_rows <- c(ord_rows, idx[o])
      bucket_lab <- c(bucket_lab, rep(bk, length(o)))
    }
  } else {
    if (!is.null(global_order_by)) {
      sidx <- .col_idx(global_order_by)
      score <- if (length(sidx) == 1) M[, sidx] else rowMeans(M[, sidx, drop = FALSE], na.rm = TRUE)
      ord_rows <- order(score, decreasing = TRUE, na.last = TRUE)
    } else {
      ord_rows <- seq_len(nrow(M))
    }
    bucket_lab <- rep("all", length(ord_rows))
  }

  M <- M[ord_rows, , drop = FALSE]
  bucket_lab <- factor(bucket_lab, levels = bucket_levels)

  # post-order debug recompute (so you can compare on the displayed matrix)
  if (isTRUE(debug_logic) && !is.null(debug_bucket) && debug_bucket %in% names(buckets)) {
    rule <- buckets[[debug_bucket]]
    pr  <- .col_idx(rule$present)
    ab  <- .col_idx(rule$absent)
    pra <- .col_idx(rule$present_all)
    pry <- .col_idx(rule$present_any)
    aba <- .col_idx(rule$absent_all)
    aby <- .col_idx(rule$absent_any)

    present_mat_post <- M > 0
    absent_mat_post  <- M == 0

    .debug$clauses_post <- list(
      present_all  = if (length(pra)) rowSums(present_mat_post[, pra, drop = FALSE], na.rm = TRUE) == length(pra) else rep(TRUE, nrow(M)),
      present_any  = if (length(pry)) rowSums(present_mat_post[, pry, drop = FALSE], na.rm = TRUE) >= 1           else rep(TRUE, nrow(M)),
      absent_all   = if (length(aba)) rowSums(absent_mat_post[,  aba, drop = FALSE], na.rm = TRUE) == length(aba) else rep(TRUE, nrow(M)),
      absent_any   = if (length(aby)) rowSums(absent_mat_post[,  aby, drop = FALSE], na.rm = TRUE) >= 1           else rep(TRUE, nrow(M)),
      present_list = if (length(pr))  rowSums(present_mat_post[, pr,  drop = FALSE], na.rm = TRUE) == length(pr)  else rep(TRUE, nrow(M)),
      absent_list  = if (length(ab))  rowSums(absent_mat_post[,  ab,  drop = FALSE], na.rm = TRUE) == length(ab)  else rep(TRUE, nrow(M))
    )
  }

  # color limits (support NA endpoints)
  if (is.null(color_limits)) {
    minv <- min(M, na.rm = TRUE)
    maxv <- max(M, na.rm = TRUE)
    lims <- c(minv, maxv)
  } else {
    lims <- as.numeric(color_limits)
    if (length(lims) != 2) stop("color_limits must be length-2.")
    if (any(is.na(lims))) {
      minv <- min(M, na.rm = TRUE)
      maxv <- max(M, na.rm = TRUE)
      if (is.na(lims[1])) lims[1] <- minv
      if (is.na(lims[2])) lims[2] <- maxv
    }
  }

  # color function
    # color function
  # Helper to pick endpoint colors from your 'colors' argument
  .neg_pos_colors <- function(lims, colors) {
    if (is.null(colors)) {
      # your defaults
      if (lims[1] < 0 && lims[2] > 0) {
        list(neg = "#3B4CC0", mid = "white", pos = "#B40426")
      } else {
        list(low = "white", high = "#006400")
      }
    } else if (is.function(colors)) {
      return(colors)  # user-provided colorRamp2
    } else {
      if (length(colors) == 2) {
        list(low = colors[1], high = colors[2])
      } else if (length(colors) >= 3 && lims[1] < 0 && lims[2] > 0) {
        list(neg = colors[1], mid = colors[2], pos = colors[length(colors)])
      } else {
        # 3+ colors but not a diverging scale crossing 0
        list(vec = colors)
      }
    }
  }

  cols_spec <- .neg_pos_colors(lims, colors)

  if (is.function(cols_spec)) {
    col_fun <- cols_spec
  } else if (!is.null(zero_white_band) && lims[1] < 0 && lims[2] > 0) {
    # --- NEW: white band around zero ---
    band <- if (length(zero_white_band) == 1) {
      c(-abs(zero_white_band), abs(zero_white_band))
    } else {
      sort(as.numeric(zero_white_band))[1:2]
    }
    neg_col <- if (!is.null(cols_spec$neg)) cols_spec$neg else if (!is.null(cols_spec$low)) cols_spec$low else "blue"
    pos_col <- if (!is.null(cols_spec$pos)) cols_spec$pos else if (!is.null(cols_spec$high)) cols_spec$high else "red"
    mid_col <- if (!is.null(cols_spec$mid)) cols_spec$mid else "white"

    # breaks: min → band_lo → 0 → band_hi → max
    brks <- c(lims[1], band[1], 0, band[2], lims[2])
    # colors: blue gradient to band_lo, then white stays flat until band_hi, then gradient to red
    cols <- c(neg_col, mid_col, mid_col, mid_col, pos_col)
    col_fun <- circlize::colorRamp2(brks, cols)
  } else {
    # Original behaviors
    if (is.null(colors)) {
      if (lims[1] < 0 && lims[2] > 0) {
        col_fun <- circlize::colorRamp2(c(lims[1], 0, lims[2]),
                                        c("#3B4CC0", "#F7F7F7", "#B40426"))
      } else {
        col_fun <- circlize::colorRamp2(c(lims[1], lims[2]),
                                        c("white", "#006400"))
      }
    } else if (is.vector(colors) && !is.null(cols_spec$vec)) {
      # arbitrary multi-stop palette
      col_fun <- circlize::colorRamp2(seq(lims[1], lims[2], length.out = length(colors)),
                                      colors)
    } else if (is.vector(colors) && length(colors) == 2) {
      col_fun <- circlize::colorRamp2(c(lims[1], lims[2]), colors)
    } else if (is.vector(colors) && length(colors) >= 3 && lims[1] < 0 && lims[2] > 0) {
      col_fun <- circlize::colorRamp2(c(lims[1], 0, lims[2]),
                                      c(cols_spec$neg, cols_spec$mid, cols_spec$pos))
    } else {
      col_fun <- circlize::colorRamp2(seq(lims[1], lims[2], length.out = length(colors)), colors)
    }
  }

  # row split if using buckets
  row_split <- if (isTRUE(use_buckets)) bucket_lab else NULL

  # build Heatmap
  ht <- Heatmap(
    M,
    name = "signal",
    col = col_fun,
    cluster_rows = if (isTRUE(use_buckets)) FALSE else cluster_rows,
    cluster_columns = cluster_cols,
    clustering_distance_rows = row_distance,
    clustering_method_rows   = row_linkage,
    clustering_distance_columns = col_distance,
    clustering_method_columns   = col_linkage,
    show_row_names = show_row_names,
    show_column_names = show_col_names,
    row_split = row_split,
    use_raster = TRUE, raster_quality = 4
  )

  # export
  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)
  height_in <- base_height_in + nrow(M) * per_row_height_in
  out_files <- character(0)

  if ("png" %in% tolower(formats)) {
    png_file <- file.path(out_dir, paste0(out_stem, ".png"))
    png(png_file, width = width_in, height = height_in, units = "in", res = dpi)
    draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
    dev.off()
    out_files <- c(out_files, png_file)
  }
  if ("pdf" %in% tolower(formats)) {
    pdf_file <- file.path(out_dir, paste0(out_stem, ".pdf"))
    pdf(pdf_file, width = width_in, height = height_in, useDingbats = FALSE)
    draw(ht, heatmap_legend_side = "right", annotation_legend_side = "right")
    dev.off()
    out_files <- c(out_files, pdf_file)
  }
  message("Saved: ", paste(out_files, collapse = " | "))

  if (return_objects) {
    invisible(list(
      matrix = M,
      row_order = rownames(M),
      bucket_labels = if (isTRUE(use_buckets)) as.character(row_split) else NULL,
      heatmap = ht,
      debug = .debug  # may be empty list if debug_logic=FALSE
    ))
  } else {
    invisible(NULL)
  }
}

```

```{r, Run Heatmap Function}
#Use without clustering
make_csaw_heatmap_advanced(
  df = H3K36me3_Heatmap_K27genes_proms_vInput,
  select_cols = NULL,                   # NULL = use all strains
  present_threshold = 0.1,                # everything <1 → 0
  clip_negatives_to_zero = FALSE,        # keep negatives
  color_limits = c(0, NA),               # start at 0, auto-max
  colors = c("white", "#A59D00"),            # white → red scale
  global_order_by = c("WT","cac1"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  show_row_names = FALSE,
  out_stem = "TEST"
)

# define the rule set: one bucket for absent in cac1 OR cac2
buck <- list(
  absent_all_cac1_or_cac2 = list(absent_all = c("cac1", "cac2")),
  absent_any_cac1_or_cac2 = list(absent_any = c("cac1", "cac2")),
  present_all_WT_cac1_or_cac2 = list(absent_all = c("WT", "cac1", "cac2")),
  present_all_cac1_or_cac2 = list(absent_all = c("cac1", "cac2"))
)

res <- make_csaw_heatmap_advanced(
  df = H3K27me3_CS_Heatmap_K27promTSS_vInput,
  select_cols = c("WT","cac1","cac2","cac3","set7"),
  present_threshold = 1,
  use_buckets = TRUE,
  buckets = buck,
  bucket_order_by = list(absent_cac1_or_cac2 = "WT"),
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  color_limits = c(0, NA),
  colors = c("white","darkgreen"),
  out_stem = "H3K27me3_TEST",
  debug_logic = TRUE,
  debug_bucket = "absent_cac1_or_cac2"
)

####

res <- make_csaw_heatmap_advanced(
  df = H3K36me3_Heatmap_K27promTSS_vWT,
  select_cols = c("cac1","cac2","cac3","set7"),
  global_filter = NULL,              # <- keep ALL rows
  cap_percentile = 0.995,
  color_limits = c(-2, 2),
  colors = c("blue","white","red"),
  zero_white_band = 0.5,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  global_order_by = c("cac1","cac2", "cac3"),
  out_dir = "csaw_heatmaps",
  out_stem = "TEST2",
  formats = c("pdf","png"),
  width_in = 6.5,
  base_height_in = 1.5,
  per_row_height_in = 0.006,
  dpi = 300,
  return_objects = TRUE
)

```

```{r, plotting HEATMAP w/ RNA-seq data}
#script to make a heatmap w ChIP log2FC data & RNA-seq log2FC data (will use csaw results, which is why i have it here)

#read in log2FC Expression data saved from DESeq for whatever strains you want
cac1RNA= read.csv("../CAF-1_RNA-seq_Analysis/csv_files/cac1_new_ALL.csv", row.names = 1)
cac2RNA= read.csv("../CAF-1_RNA-seq_Analysis/csv_files/cac2_ALL.csv", row.names = 1)
set7RNA= read.csv("../CAF-1_RNA-seq_Analysis/csv_files/set7_05.csv", row.names = 1)

#Plot heatmap with ChIP & RNA-seq log2FC

suppressPackageStartupMessages({
  library(ComplexHeatmap)
  library(circlize)
})

make_chip_rna_heatmap <- function(
  chip_results_df,
  chip_heatmap_res,                         # list from make_csaw_heatmap_advanced()
  rna_list,                                 # named list of RNA dfs; rownames are NCU IDs
  chip_cols      = c("logFC_cac1","logFC_cac2","logFC_set7"),
  rna_colname    = "log2FoldChange",

  # visual scales (ChIP)
  chip_limits    = c(-2, 2),
  chip_zero_band = 0.5,                     # white band around 0 for ChIP (visual only)
  chip_colors    = c("#3B4CC0", "white", "#B40426"),

  # visual scales (RNA)
  rna_limits     = c(-4, 4),
  rna_zero_band  = NULL,                    # e.g. 0.5 to mirror ChIP
  rna_colors     = c("blue", "white", "red"),

  # scaling
  row_scale      = c("none", "zscore_chip", "zscore_rna", "zscore_both"),

  # sorting
  sort_by        = c("none","chip","rna"),
  sort_strains   = NULL,                    # e.g. c("cac1","set7"); NULL = all columns in chosen block

  # data filter
  drop_na        = TRUE,                    # drop rows with any NA in either block

  # clamp & legends
  clamp_chip     = TRUE,
  clamp_rna      = TRUE,
  chip_legend_at     = NULL,
  chip_legend_labels = NULL,
  rna_legend_at      = NULL,
  rna_legend_labels  = NULL,

  # ---- OUTPUT & SIZE CONTROL ----
  out_dir        = NULL,                    # if non-NULL, save files here
  file_prefix    = "chip_rna_heatmap",
  save_formats   = c("pdf","png"),          # any of "pdf","png"
  width_in       = 6.5,                     # figure width in inches
  height_in      = NULL,                    # figure height in inches; if NULL -> auto by row count
  base_height_in = 1.5,                     # base height (in) added regardless of rows (used if height_in is NULL)
  per_row_height_in = 0.006,                # added height per row (in) if height_in is NULL
  dpi            = 300                      # PNG resolution; px = inches * dpi
) {
  `%||%` <- function(a, b) if (!is.null(a)) a else b

  row_scale <- match.arg(row_scale)
  sort_by   <- match.arg(sort_by)

  stopifnot(is.list(chip_heatmap_res), !is.null(chip_heatmap_res$matrix))
  chip_mat_full <- chip_heatmap_res$matrix

  # Map ChIP rows -> gene IDs via "seq.start.end"
  chip_key <- with(chip_results_df, paste(seqnames, start, end, sep = "."))
  gene_map <- setNames(chip_results_df$V10, chip_key)
  if (!all(rownames(chip_mat_full) %in% names(gene_map))) {
    missing_keys <- setdiff(rownames(chip_mat_full), names(gene_map))
    stop("Some heatmap rows not in chip_results_df key (seq.start.end). Examples: ",
         paste(head(missing_keys, 5), collapse = ", "))
  }
  genes_in_order <- gene_map[ rownames(chip_mat_full) ]

  # Keep requested ChIP columns
  keep_chip <- intersect(chip_cols, colnames(chip_mat_full))
  if (length(keep_chip) == 0) stop("None of chip_cols present in the ChIP heatmap matrix.")
  chip_sub <- chip_mat_full[, keep_chip, drop = FALSE]

  # Build RNA matrix in identical row order
  pull_rna <- function(df, genes, col = rna_colname) {
    rn <- trimws(rownames(df))
    if (is.null(rn)) stop("RNA data frame is missing rownames (NCU IDs).")
    v <- df[genes, col, drop = TRUE]
    suppressWarnings(as.numeric(v))
  }
  rna_mat <- do.call(cbind, lapply(names(rna_list), function(nm) {
    pull_rna(rna_list[[nm]], genes_in_order, rna_colname)
  }))
  colnames(rna_mat) <- paste0("RNA_", names(rna_list))
  rownames(rna_mat) <- rownames(chip_sub)

  # Drop rows with any NA across either block (e.g., rRNA/tRNA lacking RNA)
  if (isTRUE(drop_na)) {
    keep <- rowSums(is.na(chip_sub)) == 0 & rowSums(is.na(rna_mat)) == 0
    chip_sub       <- chip_sub[keep, , drop = FALSE]
    rna_mat        <- rna_mat [keep, , drop = FALSE]
    genes_in_order <- genes_in_order[keep]
  }

  # Row-wise z-scoring (post-alignment, pre-sorting, pre-clamping)
  zrow <- function(m) {
    if (ncol(m) == 1) return(m * 0)  # single column z-score -> flat zero
    mc <- m - rowMeans(m, na.rm = TRUE)
    s  <- apply(mc, 1, function(x) sd(x, na.rm = TRUE))
    s[s == 0 | is.na(s)] <- 1
    mc / s
  }
  if (row_scale %in% c("zscore_chip","zscore_both")) chip_sub <- zrow(chip_sub)
  if (row_scale %in% c("zscore_rna","zscore_both"))  rna_mat  <- zrow(rna_mat)

  # Optional sorting
  if (sort_by != "none") {
    if (sort_by == "chip") {
      cols_to_use <- if (is.null(sort_strains)) colnames(chip_sub) else {
        wanted <- paste0("logFC_", sort_strains)
        intersect(wanted, colnames(chip_sub))
      }
      mat_for_order <- chip_sub
    } else { # sort_by == "rna"
      cols_to_use <- if (is.null(sort_strains)) colnames(rna_mat) else {
        wanted <- paste0("RNA_", sort_strains)
        intersect(wanted, colnames(rna_mat))
      }
      mat_for_order <- rna_mat
    }
    if (length(cols_to_use) > 0) {
      score <- if (length(cols_to_use) == 1) {
        as.numeric(mat_for_order[, cols_to_use])
      } else {
        rowMeans(mat_for_order[, cols_to_use, drop = FALSE], na.rm = TRUE)
      }
      ord <- order(score, decreasing = TRUE, na.last = TRUE)
      chip_sub       <- chip_sub[ord, , drop = FALSE]
      rna_mat        <- rna_mat [ord, , drop = FALSE]
      genes_in_order <- genes_in_order[ord]
    }
  }

  # Clamp to limits so legend and colors match exactly
  if (isTRUE(clamp_chip)) chip_sub <- pmin(pmax(chip_sub, chip_limits[1]), chip_limits[2])
  if (isTRUE(clamp_rna))  rna_mat  <- pmin(pmax(rna_mat,  rna_limits[1]), rna_limits[2])

  # Color mapping with optional flat white band around 0
  make_diverging_fun <- function(lims, band, cols) {
    if (is.null(cols) || length(cols) < 3) cols <- c("#3B4CC0","white","#B40426")
    if (!is.null(band) && lims[1] < 0 && lims[2] > 0) {
      band <- abs(as.numeric(band))[1]
      brks <- c(lims[1], -band, 0, band, lims[2])
      pal  <- c(cols[1], "white", "white", "white", tail(cols, 1))
      circlize::colorRamp2(brks, pal)
    } else if (lims[1] < 0 && lims[2] > 0) {
      circlize::colorRamp2(c(lims[1], 0, lims[2]),
                           c(cols[1], "white", tail(cols, 1)))
    } else {
      circlize::colorRamp2(c(lims[1], lims[2]),
                           c(cols[1], tail(cols, 1)))
    }
  }
  col_fun_chip <- make_diverging_fun(chip_limits, chip_zero_band, chip_colors)
  col_fun_rna  <- make_diverging_fun(rna_limits,  rna_zero_band,  rna_colors)

  # Legend ticks default to limits
  if (is.null(chip_legend_at)) chip_legend_at <- pretty(chip_limits, n = 5)
  if (is.null(rna_legend_at))  rna_legend_at  <- pretty(rna_limits,  n = 5)

  # Build heatmaps
  ht_chip <- Heatmap(
    chip_sub,
    name = if (row_scale %in% c("zscore_chip","zscore_both")) "ChIP (z)" else "ChIP log2FC",
    col = col_fun_chip,
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    heatmap_legend_param = list(at = chip_legend_at, labels = chip_legend_labels %||% chip_legend_at)
  )
  ht_rna <- Heatmap(
    rna_mat,
    name = if (row_scale %in% c("zscore_rna","zscore_both")) "RNA (z)" else "RNA log2FC",
    col = col_fun_rna,
    na_col = "white",
    cluster_rows = FALSE,
    cluster_columns = FALSE,
    show_row_names = FALSE,
    heatmap_legend_param = list(at = rna_legend_at, labels = rna_legend_labels %||% rna_legend_at)
  )

  ht_all <- ht_chip + ht_rna

  # Determine output height
  n_rows <- nrow(chip_sub)
  eff_height_in <- if (is.null(height_in)) base_height_in + n_rows * per_row_height_in else height_in
  png_width_px  <- as.integer(round(width_in * dpi))
  png_height_px <- as.integer(round(eff_height_in * dpi))

  # Save to files if requested
  if (!is.null(out_dir)) {
    dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
    fmts <- tolower(save_formats)

    if ("pdf" %in% fmts) {
      pdf_file <- file.path(out_dir, paste0(file_prefix, ".pdf"))
      grDevices::pdf(pdf_file, width = width_in, height = eff_height_in, useDingbats = FALSE)
      draw(ht_all, heatmap_legend_side = "right")
      grDevices::dev.off()
    }

    if ("png" %in% fmts) {
      png_file <- file.path(out_dir, paste0(file_prefix, ".png"))
      grDevices::png(png_file, width = png_width_px, height = png_height_px, res = dpi)
      draw(ht_all, heatmap_legend_side = "right")
      grDevices::dev.off()
    }
  }

  # Also draw interactively (uses current device size)
  draw(ht_all, heatmap_legend_side = "right")

  invisible(list(
    chip_matrix = chip_sub,
    rna_matrix  = rna_mat,
    genes       = genes_in_order,
    size_used   = list(width_in = width_in, height_in = eff_height_in, dpi = dpi)
  ))
}

# ---------------------- Example usage ----------------------
out <- make_chip_rna_heatmap(
  chip_results_df  = H3K36me3_Results_K27promTSS_vWT,
  chip_heatmap_res = res,
  rna_list = list(cac1 = cac1RNA, cac2 = cac2RNA, set7 = set7RNA),
  chip_cols      = c("logFC_cac1","logFC_cac2","logFC_set7"),
  chip_limits    = c(-2, 2),
  chip_zero_band = 0.5,
  rna_limits     = c(-10, 10),
  rna_zero_band  = 2,
  sort_by      = "rna",
  drop_na     = TRUE,
  sort_strains = c("cac1","cac2"),
  clamp_rna      = FALSE,                        
  rna_legend_at  = NULL,
  out_dir        = "csaw_heatmaps",
  file_prefix    = "H3K36me3_vWT_vs_RNA_vWT_RNAsorted",
  save_formats = c("pdf","png"),
  width_in     = 8,
  height_in    = 7,
  dpi          = 300
)

#View RNA matrix being plotted (in correct order)
rna_df <- data.frame(GeneID = out$genes, out$rna_matrix)
View(rna_df)

```

```{r, ChIP vs. RNA scatter plot code}
#Use this to make scatterplots of ChIP-seq signal over genes vs. their RNA-seq expression values or another modifcation
## Would probably only try to use with region mode

suppressPackageStartupMessages({
  library(ggplot2)
  library(dplyr)
  library(stringr)
  library(tibble)
})

# Flexible scatter: ChIP vs RNA  OR  ChIP vs ChIP (with skew coloring)
chip_scatter_flex <- function(
  mode = c("chip_vs_rna","chip_vs_chip"),

  # --- inputs shared / aligned by gene id ---
  gene_col       = "V10",          # gene id column inside ChIP dfs

  # X axis (ChIP set A)
  chip_df_x,                        # ChIP df for X (e.g., H3K27me3 promoters)
  strain_x,                         # e.g., "cac1"
  chip_col_x     = NULL,            # auto-detect "logFC_<strain_x>"

  # Y axis (depends on mode)
  # mode="chip_vs_rna"
  rna_df         = NULL,            # rownames = gene IDs, has rna_col
  rna_col        = "log2FoldChange",
  # mode="chip_vs_chip"
  chip_df_y      = NULL,            # second ChIP df (e.g., H3K36me3 promoters)
  strain_y       = NULL,            # strain for Y
  chip_col_y     = NULL,            # auto-detect "logFC_<strain_y>"

  # --- coloring ---
  # ChIP vs RNA: color by RNA magnitude
  up_thresh      =  2,
  down_thresh    = -2,
  rna_colors_map = c(up = "red", down = "blue", ns = "gray50"),
  rna_legend_title = "RNA log2FC group",

  # ChIP vs ChIP: color by skew (difference) between modifications
  chip_diff_thresh = 1,             # threshold on (x - y) in log2 space
  chip_colors_map  = c(x_dom = "#d62728", y_dom = "#1f77b4", similar = "gray70"),
  chip_legend_title = "Skew (X vs Y)",

  # stats / fit
  cor_method     = c("pearson","spearman"),
  add_lm         = TRUE,
  fit_global     = TRUE,
  fit_color      = "black",
  fit_linetype   = "dashed",
  fit_se         = FALSE,

  # aesthetics
  point_alpha    = 0.75,
  point_size     = 1.6,

  # labels
  xlab           = NULL,
  ylab           = NULL,
  title          = NULL,
  chip_x_label   = NULL,            # e.g., "H3K27me3"
  chip_y_label   = NULL,            # e.g., "H3K36me3"

  # axes (no data drop)
  xlim           = NULL,
  ylim           = NULL,

  # hygiene
  drop_na        = TRUE,

  # output (same style as your heatmap helper)
  out_dir        = NULL,
  file_prefix    = NULL,
  save_formats   = c("pdf","png"),
  width_in       = 12,
  height_in      = 9,
  dpi            = 600
) {
  `%||%` <- function(a,b) if (!is.null(a)) a else b
  mode <- match.arg(mode)
  cor_method <- match.arg(cor_method)

  # helper: pick column
  pick_chip_col <- function(df, strain) {
    pref <- paste0("logFC_",  strain)
    fall <- paste0("log2FC_", strain)
    if (pref %in% names(df)) return(pref)
    if (fall %in% names(df)) return(fall)
    pats <- paste0("^log2?fc[._-]?", tolower(strain))
    hits <- names(df)[str_detect(tolower(names(df)), pats)]
    if (!length(hits)) stop("Could not find a ChIP column for strain '", strain, "'. Expected '", pref, "'.")
    hits[1]
  }

  # X: ChIP A
  stopifnot(gene_col %in% names(chip_df_x))
  if (is.null(chip_col_x)) chip_col_x <- pick_chip_col(chip_df_x, strain_x)
  stopifnot(chip_col_x %in% names(chip_df_x))
  x_tbl <- chip_df_x %>%
    transmute(GeneID = .data[[gene_col]], x = suppressWarnings(as.numeric(.data[[chip_col_x]])))

  # Y: depends on mode
  if (mode == "chip_vs_rna") {
    if (is.null(rna_df)) stop("Provide rna_df for mode='chip_vs_rna'.")
    if (is.null(rownames(rna_df))) stop("rna_df must have rownames as gene IDs.")
    if (!rna_col %in% colnames(rna_df)) stop("rna_col '", rna_col, "' not found in rna_df.")
    y_tbl <- rna_df %>%
      as.data.frame() %>%
      rownames_to_column("GeneID") %>%
      transmute(GeneID, y = suppressWarnings(as.numeric(.data[[rna_col]])))
  } else {
    if (is.null(chip_df_y) || is.null(strain_y)) {
      stop("Provide chip_df_y and strain_y for mode='chip_vs_chip'.")
    }
    stopifnot(gene_col %in% names(chip_df_y))
    if (is.null(chip_col_y)) chip_col_y <- pick_chip_col(chip_df_y, strain_y)
    stopifnot(chip_col_y %in% names(chip_df_y))
    y_tbl <- chip_df_y %>%
      transmute(GeneID = .data[[gene_col]], y = suppressWarnings(as.numeric(.data[[chip_col_y]])))
  }

  # align and clean
  plot_df <- inner_join(x_tbl, y_tbl, by = "GeneID")
  if (isTRUE(drop_na)) plot_df <- filter(plot_df, is.finite(x), is.finite(y))
  if (nrow(plot_df) < 3) stop("Not enough overlapping genes with finite values to plot.")

  # color grouping
  if (mode == "chip_vs_rna") {
    plot_df <- mutate(plot_df,
      color_group = case_when(
        y >  up_thresh   ~ "up",
        y <  down_thresh ~ "down",
        TRUE             ~ "ns"
      )
    )
    col_vals <- setNames(as.character(rna_colors_map[c("up","down","ns")]), c("up","down","ns"))
    legend_title <- rna_legend_title
  } else {
    # skew by difference (x - y) ~ log2 ratio x/y
    plot_df <- mutate(plot_df,
      diff_xy = x - y,
      color_group = case_when(
        diff_xy >=  chip_diff_thresh ~ "x_dom",
        diff_xy <= -chip_diff_thresh ~ "y_dom",
        TRUE                         ~ "similar"
      )
    )
    col_vals <- setNames(as.character(chip_colors_map[c("x_dom","y_dom","similar")]),
                         c("x_dom","y_dom","similar"))
    legend_title <- chip_legend_title
  }

  # stats
  ct   <- suppressWarnings(cor.test(plot_df$x, plot_df$y, method = cor_method))
  r2_s <- sprintf("%.2f", unname(ct$estimate)^2)  # always 2 decimals
  pval <- signif(ct$p.value, 3)

  # labels & title
  x_comp <- chip_x_label %||% paste0("ChIP (", strain_x, ")")
  if (mode == "chip_vs_rna") {
    y_comp <- "RNA"
  } else {
    y_comp <- chip_y_label %||% paste0("ChIP (", strain_y, ")")
  }
  if (is.null(xlab)) xlab <- paste0(x_comp, " log2FC")
  if (is.null(ylab)) ylab <- paste0(y_comp, " log2FC")
  if (is.null(title)) {
    left  <- chip_x_label %||% paste0("ChIP-", strain_x)
    right <- if (mode == "chip_vs_rna") "RNA" else (chip_y_label %||% paste0("ChIP-", strain_y))
    title <- paste0(left, " vs ", right)
  }

  # annotation
  xr <- range(plot_df$x, na.rm = TRUE); yr <- range(plot_df$y, na.rm = TRUE)
  x_anno <- xr[1] + 0.02 * diff(xr); y_anno <- yr[2] - 0.05 * diff(yr)
  anno_txt <- paste0("R² = ", r2_s, ", p = ", pval)

  # plot
  p <- ggplot(plot_df, aes(x, y, color = color_group)) +
    geom_point(alpha = point_alpha, size = point_size) +
    scale_color_manual(values = col_vals, name = legend_title) +
    theme_minimal(base_size = 12) +
    labs(x = xlab, y = ylab, title = title) +
    annotate("text", x = x_anno, y = y_anno, label = anno_txt, hjust = 0, size = 4)

  # regression line (global by default)
  if (isTRUE(add_lm) && isTRUE(fit_global)) {
    p <- p + geom_smooth(
      data = plot_df, aes(x, y),
      method = "lm", se = fit_se,
      color = fit_color, linetype = fit_linetype,
      inherit.aes = FALSE
    )
  } else if (isTRUE(add_lm)) {
    p <- p + geom_smooth(method = "lm", se = fit_se, linetype = fit_linetype)
  }

  if (!is.null(xlim) || !is.null(ylim)) p <- p + coord_cartesian(xlim = xlim, ylim = ylim, expand = TRUE)

  # save
  saved <- character(0)
  if (!is.null(out_dir)) {
    dir.create(out_dir, showWarnings = FALSE, recursive = TRUE)
    default_stem <- if (mode == "chip_vs_rna") {
      paste0("chip", strain_x, "_vs_rna")
    } else {
      paste0("chip", strain_x, "_vs_chip", strain_y)
    }
    stem <- file_prefix %||% default_stem
    fmts <- tolower(save_formats)
    if ("pdf" %in% fmts) {
      f <- file.path(out_dir, paste0(stem, ".pdf"))
      ggsave(f, plot = p, width = width_in, height = height_in, units = "in", dpi = dpi)
      saved <- c(saved, f)
    }
    if ("png" %in% fmts) {
      f <- file.path(out_dir, paste0(stem, ".png"))
      ggsave(f, plot = p, width = width_in, height = height_in, units = "in", dpi = dpi)
      saved <- c(saved, f)
    }
  }

  invisible(list(
    data  = plot_df,   # GeneID, x, y, (diff_xy), color_group
    cor   = list(r = unname(ct$estimate), r2 = as.numeric(r2_s), p = ct$p.value, method = cor_method),
    gg    = p,
    saved = saved,
    cols  = list(chip_col_x = chip_col_x, chip_col_y = chip_col_y, rna_col = rna_col, mode = mode)
  ))
}

```

```{r, use scatter plot function}
#Example Use (ChIP vs RNA)
out <- chip_scatter_flex(
  mode        = "chip_vs_rna",
  chip_df_x   = H3K36me3_Results_K27promTSS_vWT,  # X = H3K36me3
  strain_x    = "cac1",
  rna_df      = cac1RNA,                          # RNA for cac1
  chip_x_label = "H3K36me3",                      # label in axes/title
  out_dir     = "scatter_outputs",
  file_prefix = "H3K36me3_vs_RNA_cac1",
  width_in    = 12, height_in = 9, dpi = 600
)
out$gg


#Example Use (ChIP vs ChIP)
out <- chip_scatter_flex(
  mode        = "chip_vs_chip",
  chip_df_x   = H3K27me3_CS_Results_K27promTSS_vWT,  # X = H3K27me3
  strain_x    = "cac1",
  chip_df_y   = H3K36me3_Results_K27promTSS_vWT,  # Y = H3K36me3
  strain_y    = "cac1",
  chip_x_label = "H3K27me3",
  chip_y_label = "H3K36me3",
  chip_diff_thresh = 1,   # needs ≥1 log2 unit advantage to be called dominant
  chip_colors_map  = c(x_dom = "darkgreen", y_dom = "#A59D00", similar = "gray70"),
  chip_legend_title = "Skew (K27 vs K36)",
  out_dir     = "scatter_outputs",
  file_prefix = "H3K27me3_vs_H3K36me3_cac1_skew",
  width_in    = 12, height_in = 9, dpi = 600
)
out$gg


#View what your plotting
View(out$data)  

```

```{r, function to make bed files from windowCounts}
#This function will utilize enrichment calls from windowCounts to make a bed file with significantly enriched regions for a desired modification. You will feed in a data frame obtained from the analysis function, which will already contain enrichment filtered for significance (FDR &/or p-value). This function will then merge regions that neighbor each other (i.e. chromosome 1 bp 600-899 will merge with chromosome 1 bp 900-1199 if they are both present in the df), and this will create a "peak-call" like bed file with all enriched regions. It will so this by extracting the chromosome, start, and end values from the row name of the df and make it 3 separate columns, characteristic of a bed/peak call file. it will iterate across each strain (column) in the df. you can also set a threshold for size of the fragment to be included in the df to avoid interspersed small fragments (which are likely not real enrichment). For example, a threshold set to 1000 bp would not include any fragments (post-merge) below that size (i.e. at least 4 300 bp windows will have to be merged to create a frag size large enough to be included in the bed)

# Make BED-like "peak calls" from a masked heatmap df (e.g., *_Heatmap_*_vInput)
# - Expects rownames like "chrom.start.end" (we robustly parse even if chrom has dots)
# - For EACH strain column (logFC_*):
#     * keeps rows by sign (positive/negative/any) and minimum absolute value
#     * merges abutting windows (control max inter-window gap in bp)
#     * drops merged fragments smaller than min_width_bp
# - Writes one .bed per strain (3-column BED: chrom, start(0-based), end)
# - Returns a named list of data.frames invisibly
# - WINDOW mode: optional merging of nearby windows (gap <= max_gap_bp) then min-width filter
# - REGION mode: no window merging and no min-width filter (keeps your predefined regions)

suppressPackageStartupMessages({
  requireNamespace("GenomicRanges", quietly = TRUE)
  requireNamespace("IRanges",        quietly = TRUE)
})

heatmap_to_bed_peaks <- function(
  hm_df,
  out_dir,
  prefix,
  mode              = c("window","region"),
  direction         = c("positive","nonzero","negative"),
  min_value         = 0,
  merge_windows     = TRUE,              # (window mode only)
  max_gap_bp        = 0,                 # merge gaps <= this (window mode)
  min_width_bp      = 0,                 # drop merged blocks < this (window mode)
  zero_based        = TRUE,              # BED writing: 0-based starts
  write_empty_files = FALSE,
  create_dataframes = TRUE,              # create *_BED objects in .GlobalEnv

  # ---- Restore original gene-matching logic ----
  # The region set used to build hm_df (e.g., regions$K27promTSS), with coords & gene IDs.
  source_regions_df        = NULL,       # REQUIRED if promote_to_full_genes=TRUE
  source_key_cols          = c("V1","V2","V3"),  # chr,start,end in source_regions_df
  source_gene_col          = "V10",      # gene ID in source_regions_df

  # Promote to full genes by subsetting this "universe" (e.g., regions$allgenes) via gene IDs
  promote_to_full_genes    = FALSE,
  universe_df              = NULL,       # REQUIRED if promote_to_full_genes=TRUE
  universe_gene_col        = "V10",      # gene ID column in universe_df
  universe_label           = "genes",
  universe_is_zero_based   = FALSE,      # how universe_df coords are stored

  # Optional string to append in filenames (e.g., "vInput" or "vWT")
  file_norm_tag            = NULL
) {
  mode      <- match.arg(mode)
  direction <- match.arg(direction)

  if (!is.data.frame(hm_df))
    stop("hm_df must be a data.frame with rownames like 'chr.start.end'.")

  rn <- rownames(hm_df)
  if (is.null(rn) || anyNA(rn))
    stop("hm_df must have non-NA rownames like 'chr.start.end'.")

  # Parse rownames robustly: take last two dot fields as start/end (chr can contain dots)
  m  <- regexec("^(.+)\\.([0-9]+)\\.([0-9]+)$", rn)
  mm <- regmatches(rn, m)
  bad <- vapply(mm, length, integer(1L)) != 4L
  if (any(bad)) {
    stop("Could not parse some rownames into chr.start.end. Example bad rowname: ",
         rn[which(bad)[1L]])
  }
  chr   <- vapply(mm, `[`, "", 2L)
  start <- as.integer(vapply(mm, `[`, "", 3L))
  end   <- as.integer(vapply(mm, `[`, "", 4L))

  base_gr <- GenomicRanges::GRanges(
    seqnames = chr,
    ranges   = IRanges::IRanges(start = start, end = end)
  )

  # logFC columns per strain
  lfc_cols <- grep("^logFC_", colnames(hm_df), value = TRUE)
  if (!length(lfc_cols))
    stop("No columns named like 'logFC_*' found in hm_df.")

  if (!dir.exists(out_dir)) dir.create(out_dir, recursive = TRUE)

  # Helper to build the file/variable stem
  .stem <- function(strain, is_universe = FALSE) {
    cut_tag <- if (!is.null(min_value) && !isTRUE(is.na(min_value)) && min_value != 0)
      paste0("_log2FC_", as.character(min_value)) else ""
    norm_tag <- if (!is.null(file_norm_tag) && nzchar(file_norm_tag))
      paste0("_", file_norm_tag) else ""
    suffix <- if (is_universe) paste0("_", universe_label) else ""
    paste0(prefix, cut_tag, norm_tag, "_", strain, suffix)
  }

  # Key string for hm_df rows
  hm_key <- paste(chr, start, end, sep = ".")

  # If we will promote to full genes, prepare a lookup from the ORIGINAL region set
  if (isTRUE(promote_to_full_genes)) {
    if (is.null(source_regions_df))
      stop("promote_to_full_genes=TRUE requires source_regions_df (original region set).")
    if (is.null(universe_df))
      stop("promote_to_full_genes=TRUE requires universe_df (e.g., regions$allgenes).")

    # Build key for the source region set to recover gene IDs by exact coord match
    if (!all(source_key_cols %in% names(source_regions_df)))
      stop("source_key_cols not all present in source_regions_df.")
    if (!source_gene_col %in% names(source_regions_df))
      stop("source_gene_col not found in source_regions_df.")

    src_key <- paste(source_regions_df[[source_key_cols[1]]],
                     source_regions_df[[source_key_cols[2]]],
                     source_regions_df[[source_key_cols[3]]], sep = ".")
    src_gene <- as.character(source_regions_df[[source_gene_col]])
    # fast lookup: key -> gene
    # A region can map to exactly one gene in your promoter/TSS set; if duplicated, keep first.
    key2gene <- tapply(src_gene, src_key, function(x) x[1])
  }

  # Output containers
  out_list_ranges <- stats::setNames(vector("list", length(lfc_cols)),
                                     sub("^logFC_", "", lfc_cols))
  out_list_genes  <- if (isTRUE(promote_to_full_genes))
    stats::setNames(vector("list", length(lfc_cols)), sub("^logFC_", "", lfc_cols)) else NULL

  for (lc in lfc_cols) {
    strain <- sub("^logFC_", "", lc)
    vals <- hm_df[[lc]]

    keep <- switch(
      direction,
      positive = vals >  min_value,
      negative = vals < -min_value,
      nonzero  = vals != 0
    )

    gr_keep <- base_gr[keep]
    if (length(gr_keep) == 0L) {
      # write empty 3-col BED if asked
      if (write_empty_files) {
        bed_file <- file.path(out_dir, paste0(.stem(strain), ".bed"))
        file.create(bed_file)
        if (isTRUE(promote_to_full_genes)) {
          bed_file_u <- file.path(out_dir, paste0(.stem(strain, is_universe = TRUE), ".bed"))
          file.create(bed_file_u)
        }
      }
      out_list_ranges[[strain]] <- data.frame()
      if (isTRUE(promote_to_full_genes)) out_list_genes[[strain]] <- data.frame()
      next
    }

    # --- WINDOW vs REGION output (3-col BEDs) ---
    if (mode == "window" && isTRUE(merge_windows)) {
      merged <- GenomicRanges::reduce(gr_keep, min.gapwidth = as.integer(max_gap_bp) + 1L)
      if (min_width_bp > 0L) {
        merged <- merged[IRanges::width(merged) >= as.integer(min_width_bp)]
      }
      gr_out <- merged
    } else {
      gr_out <- gr_keep
    }

    # Build 3-col BED df for ranges (write & assign)
    df_ranges <- as.data.frame(gr_out)[, c("seqnames","start","end")]
    if (isTRUE(zero_based)) df_ranges$start <- as.integer(df_ranges$start) - 1L
    df_ranges$start[df_ranges$start < 0L] <- 0L
    df_ranges$seqnames <- as.character(df_ranges$seqnames)
    df_ranges$start    <- as.integer(df_ranges$start)
    df_ranges$end      <- as.integer(df_ranges$end)

    stem_ranges <- .stem(strain)
    file_ranges <- file.path(out_dir, paste0(stem_ranges, ".bed"))
    utils::write.table(df_ranges, file_ranges, sep = "\t", quote = FALSE,
                       row.names = FALSE, col.names = FALSE)
    out_list_ranges[[strain]] <- df_ranges
    if (isTRUE(create_dataframes)) {
      assign(paste0(stem_ranges, "_BED"), df_ranges, envir = .GlobalEnv)
    }

    # --- Promote to full genes (restore: source_regions_df -> gene IDs -> subset universe_df) ---
    if (isTRUE(promote_to_full_genes)) {
      # recover keys for kept windows/regions and map to gene IDs via original region set
      kept_keys <- hm_key[keep]
      # pull gene IDs for those keys (drop NAs)
      kept_genes <- key2gene[kept_keys]
      kept_genes <- unique(as.character(kept_genes[!is.na(kept_genes)]))

      if (!length(kept_genes)) {
        # nothing to subset; write empty if requested
        if (write_empty_files) {
          bed_file_u <- file.path(out_dir, paste0(.stem(strain, is_universe = TRUE), ".bed"))
          file.create(bed_file_u)
        }
        out_list_genes[[strain]] <- data.frame()
        if (isTRUE(create_dataframes)) {
          assign(paste0(.stem(strain, is_universe = TRUE), "_BED"), data.frame(), envir = .GlobalEnv)
        }
      } else {
        if (!universe_gene_col %in% names(universe_df))
          stop("universe_gene_col not found in universe_df.")

        # exact subset by gene ID
        df_genes <- universe_df[universe_df[[universe_gene_col]] %in% kept_genes, , drop = FALSE]

        # Write genes bed (keep *universe* coords as stored; only adjust to 0-based if requested for file)
        stem_genes <- .stem(strain, is_universe = TRUE)
        file_genes <- file.path(out_dir, paste0(stem_genes, ".bed"))

        # For writing: if universe is 1-based but we want BED 0-based, temporarily adjust a copy
        dfw <- df_genes
        if (isTRUE(zero_based) && !isTRUE(universe_is_zero_based)) {
          # assume universe_df has V2 as start
          if ("V2" %in% names(dfw)) {
            dfw$V2 <- as.integer(dfw$V2) - 1L
            dfw$V2[dfw$V2 < 0L] <- 0L
          }
        }
        utils::write.table(dfw, file_genes, sep = "\t", quote = FALSE,
                           row.names = FALSE, col.names = FALSE)

        out_list_genes[[strain]] <- df_genes
        if (isTRUE(create_dataframes)) {
          assign(paste0(stem_genes, "_BED"), df_genes, envir = .GlobalEnv)
        }
      }
    }
  }

  invisible(list(ranges = out_list_ranges, genes = out_list_genes))
}

```

```{r, Run BED File Function}
###You'll want to feed Heatmap dfs into this function

# Example 1: vInput heatmap, enriched regions per strain (merge abutting; min merged width 1500 bp)
peaks_win <- heatmap_to_bed_peaks(
  hm_df         = H3K36me3_Heatmap_GenomeWide_vInput,
  out_dir       = "csaw_beds/H3K36me3_vInput",
  prefix        = "H3K36me3_vInput",
  mode          = "window",
  direction     = "positive",
  min_value     = 0,
  merge_windows = TRUE,
  max_gap_bp    = 1500,
  min_width_bp  = 1000,
  zero_based    = FALSE,
  write_empty_files = TRUE
)

# Example 2: vInput heatmap, enriched regions per strain across a pre-determined region set (i.e. all genes)
peaks <- heatmap_to_bed_peaks(
  hm_df         = H3K27me3_CS_Heatmap_K27proms_vInput,  # masked heatmap over K27promTSS regions
  out_dir       = "csaw_beds/H3K27me3_vInput",
  prefix        = "H3K27me3_methylated_promoters",
  mode          = "region",
  direction     = "positive",
  min_value     = 1.5,                         
  merge_windows = FALSE,                     # ignored in region mode anyway
  zero_based    = TRUE,
  file_norm_tag = NULL,                      # OR "vInput"/"vWT" if you want it appended here
  source_regions_df = regions$K27proms, # needs to match your original region df with coords + gene IDs
  source_key_cols   = c("V1","V2","V3"),
  source_gene_col   = "V10",      # may want to use V11, which has NCUs instead of names (change below)
  promote_to_full_genes  = TRUE,
  universe_df            = regions$K27genes, #IMPORTANT: The df you want to subset
  universe_gene_col      = "V10",
  universe_label         = "genes",
  universe_is_zero_based = FALSE,          
  create_dataframes      = TRUE
)


```

```{r, Processing Dataframes}
#Use these template commands for processing dataframes to create csvs, bed files, etc. for downstream analysis or use outisde of R. Note, these are not tied to any functions, just some useful lines of code to process the outputs of the analysis functions

#reassign gene names to data frame of interest using dplyr. This is useful if you are wanting to extract out a list of genes of interest (like genes that lose K27me3 in a mutant). 
library(dplyr)

H3K36me3_Results_K27promTSS_vWT <- H3K36me3_Results_K27promTSS_vWT %>%
  left_join(
    regions$K27promTSS %>% select(V1, V2, V3, V10), #you may have to change the column names 
    by = c("seqnames" = "V1", "start" = "V2", "end" = "V3")
  )

#subset your original bed file for genes/regions of interest. For example, here, I will subset my promoter-TSS bed to only include genes that lose H3K36me3 in cac-1 or cac-2

##isolate genes of interest
CAF1_K36_lost = subset(H3K36me3_Results_K27promTSS_vWT, H3K36me3_Results_K27promTSS_vWT$logFC_cac1 < -0.75 | H3K36me3_Results_K27promTSS_vWT$logFC_cac2 < -0.75)

##subset the bed
K36_lost_bed = subset(K27_genes, K27_genes$V10 %in% CAF1_K36_lost$V10)
K36_not_lost_bed = subset(K27_genes, ! K27_genes$V10 %in% K36_lost_bed$V10)

write.table(K36_lost_bed, file = "CAF-1_H3K36me3_lost_K27_genes.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)
write.table(K36_not_lost_bed, file = "CAF-1_H3K36me3_not_lost_K27_genes.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

#Subset files from bed file function (later in script). Here, I am pulling out all genes that dont have H3K36 in ash-1, and that arent in K27 regions
gr_wt   <- GRanges(H3K36me3_allgenes_vInput_WT_BED$seqnames,
                   IRanges(H3K36me3_allgenes_vInput_WT_BED$start + 1,
                           H3K36me3_allgenes_vInput_WT_BED$end))
gr_ash1 <- GRanges(H3K36me3_allgenes_vInput_ash1_BED$seqnames,
                   IRanges(H3K36me3_allgenes_vInput_ash1_BED$start + 1,
                           H3K36me3_allgenes_vInput_ash1_BED$end))

WT_not_in_ash1 <- H3K36me3_allgenes_vInput_WT_BED[countOverlaps(gr_wt, gr_ash1) == 0, ]

H3K36me3_no_ash1 <- regions$allgenes %>%
  left_join(
    WT_not_in_ash1, #you may have to change the column names 
    by = c("V1" = "seqnames", "V2" = "start", "V3" ="end")
  )

gr_regions <- GRanges(regions$allgenes$V1, IRanges(regions$allgenes$V2, regions$allgenes$V3))
gr_wtonly  <- GRanges(WT_not_in_ash1$seqnames, IRanges(WT_not_in_ash1$start + 1, WT_not_in_ash1$end))

#No ash-1
H3K36me3_no_ash1 <- regions$allgenes[countOverlaps(gr_regions, gr_wtonly) > 0, ]

suppressPackageStartupMessages(library(GenomicRanges))

gr_A <- GRanges(H3K36me3_no_ash1$V1, IRanges(H3K36me3_no_ash1$V2 + 1, H3K36me3_no_ash1$V3))  # BED start +1
gr_B <- GRanges(regions$K27genes$V1,       IRanges(regions$K27genes$V2,       regions$K27genes$V3))     # region coords (1-based)

#No ash-1, no K27
H3K36me3_no_ash1_NOTin_K27genes <- H3K36me3_no_ash1[countOverlaps(gr_A, gr_B) == 0, ]

write.table(H3K36me3_no_ash1_NOTin_K27genes, file = "H3K36me3_no_ash1_noK27.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

write.table(CAC3_lost_only, file = "cac3_H3K27me3_promoter_LOST.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

write.table(CAF1_lost, file = "cac1-2_H3K27me3_promoter_LOST.bed", sep = "\t", quote = FALSE, row.names = FALSE, col.names = FALSE)

```